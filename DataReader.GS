/**
 * SON GÃœNCELLEME: 2026-02-11 23:59 (RAW-vs-CACHE DEBUG REVISION)
 * ======================================================
 * DATA READER - GÃœNCELLENMÄ°Å VERSÄ°YON (TÃœM SÃœTUNLAR + GEÃ‡MÄ°Å FÄ°YATLAR)
 * ------------------------------------------------------
 * SORUMLULUKLAR:
 * 1. Google Sheet'ten HAM VERÄ°YÄ° okur (CONFIG.SHEETS.PORTFOY)
 * 2. TÃœM SÃœTUNLARI okur (A:AQ gibi) - 44 sÃ¼tun
 * 3. Veriyi temel JavaScript objelerine Ã§evirir
 * 4. HÄ°Ã‡BÄ°R finansal hesaplama yapmaz
 * 5. Cache mekanizmasÄ± iÃ§erir (performans iÃ§in)
 * 6. GeÃ§miÅŸ fiyat verilerini okur
 * ======================================================
 */
const DataReader = {

  /**
   * Cache iÃ§in Ã¶zellikler - GENÄ°ÅLETÄ°LMÄ°Å
   */
  _cache: {
    portfolio: null,
    historicalSTOCK: null,
    historicalCURRENCY: null,
    historicalGOLD: null,
    lastFetchPortfolio: null,
    lastFetchSTOCK: null,
    lastFetchCURRENCY: null,
    lastFetchGOLD: null,
    CACHE_DURATION: 5 * 60 * 1000, // 5 dakika (milisaniye)
  },

  /**
   * Parse davranÄ±ÅŸÄ± seÃ§enekleri
   * numericEmptyAsNull=true olduÄŸunda boÅŸ numeric hÃ¼creler 0 yerine null dÃ¶ner.
   */
  _parseOptions: {
    numericEmptyAsNull: false
  },

  setParseOptions(options = {}) {
    this._parseOptions = {
      ...this._parseOptions,
      ...options
    };
    console.log(`âš™ï¸ Parse options gÃ¼ncellendi: ${JSON.stringify(this._parseOptions)}`);
  },

  getParseOptions() {
    return { ...this._parseOptions };
  },

  // ==================== MEVCUT PORFÃ–Y OKUMA KODLARI ====================
  
  /**
   * Ana fonksiyon: PortfÃ¶y verilerini okur (cache'li)
   * @returns {Array<Object>} TÃ¼m portfÃ¶y verileri (tÃ¼m sÃ¼tunlar)
   */
  readPortfolio(forceRefresh = false) {
    console.log('ğŸ“– DataReader: PortfÃ¶y verileri okunuyor...');
    
    // Cache kontrolÃ¼
    if (!forceRefresh && this._cache.portfolio && this._cache.lastFetchPortfolio) {
      const age = new Date().getTime() - this._cache.lastFetchPortfolio.getTime();
      if (age < this._cache.CACHE_DURATION) {
        console.log('ğŸ’¾ Cache\'den veri dÃ¶ndÃ¼rÃ¼lÃ¼yor');
        return this._cache.portfolio;
      }
    }
    
    try {
      // 1. Sheet'i aÃ§
      const sheet = this._getPortfolioSheet();
      if (!sheet) {
        console.error('âŒ PortfÃ¶y sheet\'i bulunamadÄ±');
        return [];
      }

      // 2. TÃ¼m veriyi oku (tÃ¼m sÃ¼tunlar)
      const allData = this._readAllData(sheet);
      
      if (allData.length === 0) {
        console.warn('âš ï¸ PortfÃ¶y sheet\'inde veri yok');
        return [];
      }

      // 3. Veriyi CONFIG.COLUMNS yapÄ±sÄ±na gÃ¶re objelere dÃ¶nÃ¼ÅŸtÃ¼r
      const portfolio = this._convertToObjects(allData);
      
      // 4. Cache'e kaydet
      this._cache.portfolio = portfolio;
      this._cache.lastFetchPortfolio = new Date();
      
      console.log(`âœ… ${portfolio.length} portfÃ¶y kaydÄ± okundu ve cache'lendi`);
      return portfolio;
      
    } catch (error) {
      console.error('âŒ PortfÃ¶y okuma hatasÄ±:', error);
      return [];
    }
  },

  /**
   * Cache'i temizle
   */
  clearCache() {
    this._cache = {
      portfolio: null,
      historicalSTOCK: null,
      historicalCURRENCY: null,
      historicalGOLD: null,
      lastFetchPortfolio: null,
      lastFetchSTOCK: null,
      lastFetchCURRENCY: null,
      lastFetchGOLD: null,
      CACHE_DURATION: 5 * 60 * 1000,
    };
    console.log('ğŸ—‘ï¸ DataReader cache temizlendi');
  },

  // ==================== GEÃ‡MÄ°Å FÄ°YAT VERÄ°LERÄ° OKUMA ====================

  /**
   * Hisse geÃ§miÅŸ fiyatlarÄ±nÄ± oku
   */
  readHistoricalStockPrices(forceRefresh = false) {
    return this._readHistoricalData('HISSE_GECMIS_GUNLUK', 'STOCK', forceRefresh);
  },

  /**
   * DÃ¶viz geÃ§miÅŸ fiyatlarÄ±nÄ± oku
   */
  readHistoricalCurrencyPrices(forceRefresh = false) {
    return this._readHistoricalData('DOVIZ_GECMIS_GUNLUK', 'CURRENCY', forceRefresh);
  },

  /**
   * AltÄ±n geÃ§miÅŸ fiyatlarÄ±nÄ± oku
   */
  readHistoricalGoldPrices(forceRefresh = false) {
    return this._readHistoricalData('ALTIN_GECMIS_GUNLUK', 'GOLD', forceRefresh);
  },

  /**
   * Genel geÃ§miÅŸ veri okuma fonksiyonu
   */
  _readHistoricalData(sheetType, dataType, forceRefresh = false) {
    console.log(`ğŸ“Š DataReader: ${sheetType} geÃ§miÅŸ verileri okunuyor...`);
    
    // Cache kontrolÃ¼
    const cacheKey = `historical${dataType}`;
    if (!forceRefresh && this._cache[cacheKey] && this._cache[`lastFetch${dataType}`]) {
      const age = new Date().getTime() - this._cache[`lastFetch${dataType}`].getTime();
      if (age < this._cache.CACHE_DURATION) {
        console.log(`ğŸ’¾ ${sheetType} cache'den dÃ¶ndÃ¼rÃ¼lÃ¼yor`);
        return this._cache[cacheKey];
      }
    }
    
    try {
      const sheet = this._getHistoricalSheet(sheetType);
      if (!sheet) {
        console.error(`âŒ ${sheetType} sheet'i bulunamadÄ±`);
        return [];
      }

      // Veriyi oku
      const data = this._readHistoricalSheetData(sheet, sheetType);
      
      if (data.length === 0) {
        console.warn(`âš ï¸ ${sheetType} sheet'inde veri yok`);
        return [];
      }

      // Veriyi objelere dÃ¶nÃ¼ÅŸtÃ¼r
      const historicalData = this._convertHistoricalData(data, dataType);
      
      // Cache'e kaydet
      this._cache[cacheKey] = historicalData;
      this._cache[`lastFetch${dataType}`] = new Date();
      
      console.log(`âœ… ${historicalData.length} ${sheetType} kaydÄ± okundu ve cache'lendi`);
      return historicalData;
      
    } catch (error) {
      console.error(`âŒ ${sheetType} okuma hatasÄ±:`, error);
      return [];
    }
  },

  /**
   * GeÃ§miÅŸ veri sheet'ini getir
   */
  _getHistoricalSheet(sheetType) {
    try {
      const sheetConfig = CONFIG.SHEETS[sheetType];
      if (!sheetConfig) {
        console.error(`âŒ ${sheetType} konfigÃ¼rasyonu bulunamadÄ±`);
        return null;
      }
      
      // PortfÃ¶yle aynÄ± spreadsheet'i kullan
      const ss = SpreadsheetApp.openById(CONFIG.SHEETS.PORTFOY.ID);
      const sheet = ss.getSheetByName(sheetConfig.NAME);
      
      if (!sheet) {
        console.error(`âŒ Sheet "${sheetConfig.NAME}" bulunamadÄ±`);
        return null;
      }
      
      return sheet;
    } catch (error) {
      console.error(`âŒ Sheet aÃ§ma hatasÄ± (${sheetType}):`, error);
      return null;
    }
  },

  /**
   * Sheet'ten veriyi oku
   */
  _readHistoricalSheetData(sheet, sheetType) {
    try {
      const config = CONFIG.SHEETS[sheetType];
      
      // Son satÄ±r ve sÃ¼tun sayÄ±sÄ±nÄ± al
      const lastRow = sheet.getLastRow();
      const lastCol = sheet.getLastColumn();
      
      console.log(`   ğŸ“Š Sheet boyutu: ${lastRow} satÄ±r, ${lastCol} sÃ¼tun`);
      
      if (lastRow < config.FIRST_DATA_ROW) {
        return [];
      }
      
      // Okunacak satÄ±r sayÄ±sÄ±
      const startRow = config.FIRST_DATA_ROW;
      const numRows = lastRow - startRow + 1;
      
      console.log(`   ğŸ“– Okuma aralÄ±ÄŸÄ±: ${startRow}.satÄ±rdan ${numRows} satÄ±r, ${lastCol} sÃ¼tun`);
      
      const range = sheet.getRange(startRow, 1, numRows, lastCol);
      const data = range.getValues();
      
      console.log(`   ğŸ“¦ ${data.length} satÄ±r veri okundu`);
      return data;
      
    } catch (error) {
      console.error('âŒ GeÃ§miÅŸ veri okuma hatasÄ±:', error);
      return [];
    }
  },

  /**
   * GeÃ§miÅŸ veriyi objelere dÃ¶nÃ¼ÅŸtÃ¼r
   */
  _convertHistoricalData(data, dataType) {
    console.log(`   ğŸ”„ ${dataType} verisi object'lere dÃ¶nÃ¼ÅŸtÃ¼rÃ¼lÃ¼yor...`);
    
    // Sheet tipini belirle
    let sheetType, columnConfig;
    switch (dataType) {
      case 'STOCK':
        sheetType = 'HISSE_GECMIS_GUNLUK';
        columnConfig = CONFIG.SHEETS[sheetType].COLUMNS;
        break;
      case 'CURRENCY':
        sheetType = 'DOVIZ_GECMIS_GUNLUK';
        columnConfig = CONFIG.SHEETS[sheetType].COLUMNS;
        break;
      case 'GOLD':
        sheetType = 'ALTIN_GECMIS_GUNLUK';
        columnConfig = CONFIG.SHEETS[sheetType].COLUMNS;
        break;
      default:
        console.error(`âŒ Bilinmeyen dataType: ${dataType}`);
        return [];
    }
    
    return data.map((row, rowIndex) => {
      try {
        // Ä°lk sÃ¼tun (sembol/tÃ¼r) boÅŸsa atla
        const firstCol = columnConfig.SYMBOL !== undefined ? columnConfig.SYMBOL : columnConfig.TYPE;
        if (firstCol >= row.length || !row[firstCol]) {
          return null;
        }
        
        // Temel obje oluÅŸtur
        const obj = {
          // Sembol veya TÃ¼r
          symbol: dataType === 'GOLD' ? this._getValue(row, columnConfig.TYPE) : this._getValue(row, columnConfig.SYMBOL),
          
          // Tarih
          date: this._parseDate(this._getValue(row, columnConfig.DATE)),
          
          // Fiyat bilgileri
          open: this._getNumericValue(row, columnConfig.OPEN),
          high: this._getNumericValue(row, columnConfig.HIGH),
          low: this._getNumericValue(row, columnConfig.LOW),
          close: this._getNumericValue(row, columnConfig.CLOSE), // GÃ¼ncel fiyat
          
          // Asset tipi
          type: dataType,
          
          // Meta bilgiler
          __rawRow: row,
          __rowNumber: CONFIG.SHEETS[sheetType].FIRST_DATA_ROW + rowIndex
        };
        
        // Hacim (sadece hisse ve altÄ±n iÃ§in)
        if (dataType !== 'CURRENCY') {
          obj.volume = this._getNumericValue(row, columnConfig.VOLUME);
        }
        
        // Kaynak bilgisi
        if (dataType === 'CURRENCY') {
          // DÃ¶viz iÃ§in: kaynak ve zaman damgasÄ±
          const sourceField = this._getValue(row, columnConfig.SOURCE);
          obj.source = sourceField;
          
          // Zaman damgasÄ± varsa ekle
          if (columnConfig.TIMESTAMP !== undefined) {
            obj.timestamp = this._parseDate(this._getValue(row, columnConfig.TIMESTAMP));
          }
        } else {
          // Hisse ve altÄ±n iÃ§in kaynak
          obj.source = this._getValue(row, columnConfig.SOURCE);
        }
        
        return obj;
        
      } catch (error) {
        console.error(`âŒ ${dataType} satÄ±r ${rowIndex + 1} dÃ¶nÃ¼ÅŸtÃ¼rÃ¼lÃ¼rken hata:`, error);
        return null;
      }
    }).filter(item => item !== null);
  },

  // ==================== FÄ°YAT SORGULAMA FONKSÄ°YONLARI ====================

  /**
   * Bir varlÄ±ÄŸÄ±n gÃ¼ncel fiyatÄ±nÄ± getir
   */
  getCurrentPrice(symbol, assetType) {
    let historicalData;
    
    switch (assetType) {
      case 'STOCK':
        historicalData = this.readHistoricalStockPrices();
        break;
      case 'CURRENCY':
        historicalData = this.readHistoricalCurrencyPrices();
        break;
      case 'GOLD':
        historicalData = this.readHistoricalGoldPrices();
        break;
      default:
        console.error(`âŒ GeÃ§ersiz asset type: ${assetType}`);
        return null;
    }
    
    if (historicalData.length === 0) {
      console.warn(`âš ï¸ ${assetType} verisi boÅŸ`);
      return null;
    }
    
    // Sembole gÃ¶re filtrele (bÃ¼yÃ¼k/kÃ¼Ã§Ã¼k harf duyarsÄ±z)
    const assetRecords = historicalData.filter(item => {
      if (!item || !item.symbol) return false;
      
      const itemSymbol = item.symbol.toString().trim().toLowerCase();
      const searchSymbol = symbol.toString().trim().toLowerCase();
      
      return itemSymbol === searchSymbol;
    });
    
    if (assetRecords.length === 0) {
      // Alternatif sembol arama
      console.log(`ğŸ” "${symbol}" iÃ§in alternatif arama yapÄ±lÄ±yor...`);
      
      // Dolar iÃ§in alternatifler
      if (symbol === 'USD' || symbol === 'USD/TRY') {
        const usdRecords = historicalData.filter(item => 
          item.symbol && item.symbol.toString().toLowerCase().includes('usd')
        );
        if (usdRecords.length > 0) {
          return this._getLatestRecord(usdRecords);
        }
      }
      
      // Euro iÃ§in alternatifler
      if (symbol === 'EUR' || symbol === 'EUR/TRY') {
        const eurRecords = historicalData.filter(item => 
          item.symbol && item.symbol.toString().toLowerCase().includes('eur')
        );
        if (eurRecords.length > 0) {
          return this._getLatestRecord(eurRecords);
        }
      }
      
      console.warn(`âš ï¸ "${symbol}" ${assetType} verisinde bulunamadÄ±`);
      return null;
    }
    
    return this._getLatestRecord(assetRecords);
  },

  /**
   * KayÄ±tlardan en gÃ¼ncel olanÄ± getir
   */
  _getLatestRecord(records) {
    if (!records || records.length === 0) {
      return null;
    }
    
    // Tarihe gÃ¶re sÄ±rala (en yeni en baÅŸta)
    const sorted = [...records].sort((a, b) => {
      const dateA = a.date ? new Date(a.date).getTime() : 0;
      const dateB = b.date ? new Date(b.date).getTime() : 0;
      return dateB - dateA;
    });
    
    const latest = sorted[0];
    
    return {
      price: latest.close,
      date: latest.date,
      source: latest.source || 'Unknown',
      symbol: latest.symbol,
      type: latest.type
    };
  },

  /**
   * Dolar fiyatÄ±nÄ± getir
   */
  getDolarPrice() {
    return this.getCurrentPrice('USDTRY=X', 'CURRENCY') || 
           this.getCurrentPrice('USD', 'CURRENCY');
  },

  /**
   * Euro fiyatÄ±nÄ± getir
   */
  getEuroPrice() {
    return this.getCurrentPrice('EURTRY=X', 'CURRENCY') || 
           this.getCurrentPrice('EUR', 'CURRENCY');
  },

  /**
   * Gram altÄ±n fiyatÄ±nÄ± getir
   */
  getGramAltinPrice() {
    return this.getCurrentPrice('gram-altin', 'GOLD');
  },

  /**
   * Ons altÄ±n fiyatÄ±nÄ± getir
   */
  getOnsAltinPrice() {
    return this.getCurrentPrice('ons', 'GOLD');
  },

  /**
   * PortfÃ¶ydeki bir varlÄ±ÄŸÄ±n fiyatÄ±nÄ± getir
   */
  getPortfolioItemPrice(item) {
    if (!item) return null;
    
    const { kategori, birimi, baslik } = item;
    
    // Kategoriye gÃ¶re asset type belirle
    if (kategori && kategori.includes('Borsa')) {
      return this.getCurrentPrice(baslik, 'STOCK');
    }
    else if (kategori === 'DÃ¶viz' || birimi === 'USD' || birimi === 'EUR') {
      const symbol = birimi === 'USD' ? 'USDTRY=X' : 
                     birimi === 'EUR' ? 'EURTRY=X' : birimi;
      return this.getCurrentPrice(symbol, 'CURRENCY');
    }
    else if (kategori && (kategori.includes('AltÄ±n') || kategori.includes('GÃ¼mÃ¼ÅŸ'))) {
      // BaÅŸlÄ±ktan altÄ±n tÃ¼rÃ¼nÃ¼ tahmin et
      const baslikLower = baslik.toLowerCase();
      let goldType;
      
      if (baslikLower.includes('gram')) goldType = 'gram-altin';
      else if (baslikLower.includes('ons')) goldType = 'ons';
      else if (baslikLower.includes('Ã§eyrek') || baslikLower.includes('ceyrek')) goldType = 'ceyrek-altin';
      else if (baslikLower.includes('yarÄ±m') || baslikLower.includes('yarim')) goldType = 'yarim-altin';
      else if (baslikLower.includes('tam')) goldType = 'tam-altin';
      else goldType = baslikLower;
      
      return this.getCurrentPrice(goldType, 'GOLD');
    }
    
    console.warn(`âš ï¸ Bilinmeyen kategori: ${kategori}`);
    return null;
  },

  /**
   * TÃ¼m Ã¶nemli fiyatlarÄ± getir
   */
  getAllImportantPrices() {
    return {
      dolar: this.getDolarPrice(),
      euro: this.getEuroPrice(),
      gramAltin: this.getGramAltinPrice(),
      onsAltin: this.getOnsAltinPrice(),
      timestamp: new Date()
    };
  },

  // ==================== DEBUG FONKSÄ°YONLARI ====================

  /**
   * KarÅŸÄ±laÅŸtÄ±rma iÃ§in deÄŸeri normalize et
   */
  _normalizeForCompare(value) {
    if (value === null || value === undefined || value === '') return '';
    if (value instanceof Date) {
      return isNaN(value.getTime()) ? '' : value.toISOString().slice(0, 10);
    }
    if (typeof value === 'number') {
      return Number.isFinite(value) ? Number(value.toFixed(8)) : 0;
    }
    return value.toString().trim();
  },

  /**
   * Cache satÄ±rÄ± iÃ§in Ã¶zet bilgi Ã¼ret
   */
  _getCacheStatus(cacheKey, lastFetchKey, label) {
    const cacheData = this._cache[cacheKey];
    const lastFetch = this._cache[lastFetchKey];
    const now = new Date().getTime();
    const ttlMs = this._cache.CACHE_DURATION;

    const count = Array.isArray(cacheData) ? cacheData.length : 0;
    const ageMs = lastFetch ? now - lastFetch.getTime() : null;

    return {
      label: label,
      cacheKey: cacheKey,
      count: count,
      ageSec: ageMs !== null ? Math.floor(ageMs / 1000) : null,
      remainingSec: ageMs !== null ? Math.max(0, Math.floor((ttlMs - ageMs) / 1000)) : null,
      isExpired: ageMs !== null ? ageMs >= ttlMs : false,
      lastFetchIso: lastFetch ? lastFetch.toISOString() : null,
      sample: Array.isArray(cacheData) && cacheData.length > 0 ? cacheData[0] : null
    };
  },

  /**
   * Cache'e basÄ±lan verileri gÃ¶ster (Ã¶zet + Ã¶rnek)
   */
  debugCacheStatus(options = {}) {
    const showSamples = options.showSamples !== false;

    console.log('ğŸ’¾ DATA READER CACHE KONTROLÃœ');

    const rows = [
      this._getCacheStatus('portfolio', 'lastFetchPortfolio', 'PORTFÃ–Y'),
      this._getCacheStatus('historicalSTOCK', 'lastFetchSTOCK', 'HÄ°SSE GEÃ‡MÄ°Å'),
      this._getCacheStatus('historicalCURRENCY', 'lastFetchCURRENCY', 'DÃ–VÄ°Z GEÃ‡MÄ°Å'),
      this._getCacheStatus('historicalGOLD', 'lastFetchGOLD', 'ALTIN GEÃ‡MÄ°Å')
    ];

    rows.forEach(row => {
      const ageText = row.ageSec === null ? '-' : `${row.ageSec}s`;
      const ttlText = row.remainingSec === null ? '-' : `${row.remainingSec}s`;
      const state = row.count === 0 ? 'BOÅ' : row.isExpired ? 'SÃœRESÄ° DOLDU' : 'AKTÄ°F';
      console.log(`   ${row.label.padEnd(14)} | durum=${state.padEnd(12)} | kayÄ±t=${String(row.count).padStart(5)} | yaÅŸ=${ageText.padStart(6)} | ttl=${ttlText.padStart(6)}`);

      if (showSamples) {
        if (row.sample) {
          if (row.cacheKey === 'portfolio') {
            console.log(`      â†³ Ã¶rnek: id=${row.sample.id || '-'}, baÅŸlÄ±k=${row.sample.baslik || '-'}, kategori=${row.sample.kategori || '-'}, adet=${row.sample.adet || 0}`);
          } else {
            console.log(`      â†³ Ã¶rnek: symbol=${row.sample.symbol || '-'}, date=${row.sample.date || '-'}, close=${row.sample.close || '-'}`);
          }
        } else {
          console.log('      â†³ Ã¶rnek: -');
        }
      }
    });
  },

  /**
   * Ham portfÃ¶y satÄ±rÄ± ile parse edilmiÅŸ objeyi karÅŸÄ±laÅŸtÄ±r
   */
  debugRawVsParsed(options = {}) {
    const forceRefresh = options.forceRefresh === true;
    const limit = options.limit || 5;

    console.log('ğŸ” HAM VERÄ° vs PARSE EDÄ°LEN VERÄ° (PORTFÃ–Y)');

    try {
      const sheet = this._getPortfolioSheet();
      if (!sheet) {
        console.log('   âŒ PortfÃ¶y sheet bulunamadÄ±');
        return;
      }

      const rawData = this._readAllData(sheet);
      const parsedData = this.readPortfolio(forceRefresh);

      console.log(`   Ham satÄ±r: ${rawData.length}`);
      console.log(`   Parse kayÄ±t: ${parsedData.length}`);

      const checks = [
        ['id', 'ID'],
        ['baslik', 'BASLIK'],
        ['kategori', 'KATEGORI'],
        ['birimi', 'BIRIMI'],
        ['adet', 'ADET'],
        ['birimFiyat', 'BIRIM_FIYAT'],
        ['yatirilanTutar', 'YATIRILAN_TUTAR']
      ];

      const rowCount = Math.min(limit, rawData.length, parsedData.length);
      let mismatchCount = 0;

      for (let i = 0; i < rowCount; i++) {
        const raw = rawData[i];
        const parsed = parsedData[i];
        if (!parsed) continue;

        const errors = [];
        checks.forEach(([field, columnKey]) => {
          const colIndex = CONFIG.COLUMNS[columnKey];
          const rawValue = colIndex !== undefined ? this._normalizeForCompare(raw[colIndex]) : '';
          const parsedValue = this._normalizeForCompare(parsed[field]);
          if (rawValue !== parsedValue) {
            errors.push(`${field}: raw="${rawValue}" parsed="${parsedValue}"`);
          }
        });

        if (errors.length > 0) {
          mismatchCount += 1;
          console.log(`   âš ï¸ SatÄ±r ${i + 1} farklarÄ±:`);
          errors.forEach(err => console.log(`      - ${err}`));
        }
      }

      if (mismatchCount === 0) {
        console.log(`   âœ… Ä°lk ${rowCount} satÄ±rda kritik alanlarda fark yok`);
      } else {
        console.log(`   âš ï¸ Ä°lk ${rowCount} satÄ±rda ${mismatchCount} satÄ±rda fark var`);
      }

    } catch (error) {
      console.error('âŒ Ham/parse karÅŸÄ±laÅŸtÄ±rma hatasÄ±:', error);
    }
  },

  /**
   * GeÃ§miÅŸ veriler iÃ§in ham satÄ±r/kayÄ±t sayÄ±sÄ± kontrolÃ¼
   */
  debugHistoricalData(options = {}) {
    const forceRefresh = options.forceRefresh === true;

    console.log('ğŸ” GEÃ‡MÄ°Å VERÄ° KONTROLÃœ (HAM vs PARSE)');

    const checks = [
      ['HISSE_GECMIS_GUNLUK', 'STOCK', this.readHistoricalStockPrices.bind(this)],
      ['DOVIZ_GECMIS_GUNLUK', 'CURRENCY', this.readHistoricalCurrencyPrices.bind(this)],
      ['ALTIN_GECMIS_GUNLUK', 'GOLD', this.readHistoricalGoldPrices.bind(this)]
    ];

    checks.forEach(([sheetType, label, readerFn]) => {
      try {
        const sheet = this._getHistoricalSheet(sheetType);
        const rawRows = sheet ? this._readHistoricalSheetData(sheet, sheetType) : [];
        const parsed = readerFn(forceRefresh);

        console.log(`   ${label.padEnd(8)} | ham=${rawRows.length} | parse=${parsed.length}`);
        if (parsed.length > 0) {
          const item = parsed[0];
          console.log(`      â†³ Ã¶rnek: symbol=${item.symbol || '-'}, date=${item.date || '-'}, close=${item.close || '-'}`);
        }
      } catch (e) {
        console.log(`   âŒ ${label} kontrolÃ¼nde hata: ${e.message}`);
      }
    });

    this.debugCacheStatus({ showSamples: true });
  },

  /**
   * Ana debug fonksiyonu: ham/parse doÄŸruluÄŸu + cache kontrolÃ¼
   */
  debugDataStructure(options = {}) {
    this.debugRawVsParsed({
      forceRefresh: options.forceRefresh === true,
      limit: options.limit || 5
    });

    this.debugCacheStatus({
      showSamples: options.showSamples !== false
    });
  },

  /**
   * TÃ¼m debug kontrollerini sÄ±rayla Ã§alÄ±ÅŸtÄ±r
   */
  debugAllData(options = {}) {
    console.log('ğŸ§ª DATA READER DEBUG (TAM KONTROL)');
    this.debugDataStructure(options);
    this.debugHistoricalData(options);
  },

  // ==================== MEVCUT YARDIMCI FONKSÄ°YONLAR ====================

  /**
   * PortfÃ¶y sheet'ini bul ve dÃ¶ndÃ¼r
   */
  _getPortfolioSheet() {
    try {
      const sheetConfig = CONFIG.SHEETS.PORTFOY;
      
      // Spesifik sheet ID varsa onu kullan, yoksa aktif spreadsheet'i
      let ss;
      if (sheetConfig.ID) {
        ss = SpreadsheetApp.openById(sheetConfig.ID);
      } else {
        ss = SpreadsheetApp.getActiveSpreadsheet();
      }
      
      const sheet = ss.getSheetByName(sheetConfig.NAME);
      
      if (!sheet) {
        console.error(`âŒ Sheet "${sheetConfig.NAME}" bulunamadÄ±`);
        console.log(`â„¹ï¸ Mevcut sheet'ler:`, ss.getSheets().map(s => s.getName()));
      }
      
      return sheet;
    } catch (error) {
      console.error('âŒ Sheet aÃ§ma hatasÄ±:', error);
      return null;
    }
  },

  /**
   * Sheet'ten tÃ¼m veriyi oku (tÃ¼m sÃ¼tunlar)
   */
  _readAllData(sheet) {
    try {
      const config = CONFIG.SHEETS.PORTFOY;
      
      // Son satÄ±r ve sÃ¼tun sayÄ±sÄ±nÄ± al
      const lastRow = sheet.getLastRow();
      const lastCol = sheet.getLastColumn();
      
      console.log(`ğŸ“Š Sheet boyutu: ${lastRow} satÄ±r, ${lastCol} sÃ¼tun`);
      
      if (lastRow <= 1) {
        return [];
      }
      
      // CONFIG'teki tÃ¼m sÃ¼tunlarÄ± kapsayacak ÅŸekilde oku
      // CONFIG.COLUMNS'taki maksimum sÃ¼tun indeksini bul
      const maxConfigCol = Math.max(...Object.values(CONFIG.COLUMNS));
      
      // Okunacak sÃ¼tun sayÄ±sÄ±: sheet'teki sÃ¼tun sayÄ±sÄ± ve CONFIG gereksinimi arasÄ±nda maksimum
      const numCols = Math.max(lastCol, maxConfigCol + 1);
      
      // CONFIG'te belirtilen ilk veri satÄ±rÄ±ndan baÅŸlayarak oku
      const startRow = config.FIRST_DATA_ROW;
      const numRows = lastRow - startRow + 1;
      
      console.log(`ğŸ“– Okuma aralÄ±ÄŸÄ±: ${startRow}.satÄ±rdan ${numRows} satÄ±r, ${numCols} sÃ¼tun`);
      console.log(`âš™ï¸ CONFIG gereksinimi: ${maxConfigCol + 1} sÃ¼tun`);
      
      const range = sheet.getRange(startRow, 1, numRows, numCols);
      const data = range.getValues();
      
      console.log(`ğŸ“¦ ${data.length} satÄ±r veri okundu (her satÄ±r ${data[0]?.length || 0} sÃ¼tun)`);
      return data;
      
    } catch (error) {
      console.error('âŒ Veri okuma hatasÄ±:', error);
      return [];
    }
  },

  /**
   * Ham veriyi CONFIG.COLUMNS yapÄ±sÄ±na gÃ¶re objelere dÃ¶nÃ¼ÅŸtÃ¼r (TÃœM SÃœTUNLAR)
   */
  _convertToObjects(data) {
    console.log('ğŸ”„ Ham veri object\'lere dÃ¶nÃ¼ÅŸtÃ¼rÃ¼lÃ¼yor...');
    
    return data.map((row, rowIndex) => {
      try {
        // TÃ¼m CONFIG.COLUMNS alanlarÄ±nÄ± oku
        const obj = {
          // Ham veriyi koru (debug iÃ§in)
          __rawRow: row,
          __rowNumber: CONFIG.SHEETS.PORTFOY.FIRST_DATA_ROW + rowIndex,
          
          // ==================== TEMEL BÄ°LGÄ°LER ====================
          id: this._getValue(row, CONFIG.COLUMNS.ID),
          tarih: this._parseDate(this._getValue(row, CONFIG.COLUMNS.TARIH)),
          islemTuru: this._getValue(row, CONFIG.COLUMNS.ISLEM_TURU),
          birimi: this._getValue(row, CONFIG.COLUMNS.BIRIMI),
          birimFiyat: this._getNumericValue(row, CONFIG.COLUMNS.BIRIM_FIYAT),
          baslik: this._getValue(row, CONFIG.COLUMNS.BASLIK),
          adet: this._getNumericValue(row, CONFIG.COLUMNS.ADET),
          kategori: this._getValue(row, CONFIG.COLUMNS.KATEGORI),
          platform: this._getValue(row, CONFIG.COLUMNS.PLATFORM),
          detaylar: this._getValue(row, CONFIG.COLUMNS.DETAYLAR),

          // ==================== YATIRILAN DEÄERLER ====================
          yatirilanTutar: this._getNumericValue(row, CONFIG.COLUMNS.YATIRILAN_TUTAR),
          yatirilanTL: this._getNumericValue(row, CONFIG.COLUMNS.YATIRILAN_TL),
          yatirilanUSD: this._getNumericValue(row, CONFIG.COLUMNS.YATIRILAN_USD),
          yatirilanEUR: this._getNumericValue(row, CONFIG.COLUMNS.YATIRILAN_EUR),
          yatirilanAltin: this._getNumericValue(row, CONFIG.COLUMNS.YATIRILAN_ALTIN),

          // ==================== GÃœNCEL DEÄERLER ====================
          guncelTutar: this._getNumericValue(row, CONFIG.COLUMNS.GUNCEL_TUTAR),
          guncelTL: this._getNumericValue(row, CONFIG.COLUMNS.GUNCEL_TL),
          guncelUSD: this._getNumericValue(row, CONFIG.COLUMNS.GUNCEL_USD),
          guncelEUR: this._getNumericValue(row, CONFIG.COLUMNS.GUNCEL_EUR),
          guncelAltin: this._getNumericValue(row, CONFIG.COLUMNS.GUNCEL_ALTIN),

          // ==================== KAR / ZARAR ====================
          karZararTutar: this._getNumericValue(row, CONFIG.COLUMNS.KAR_ZARAR_TUTAR),
          karZararTL: this._getNumericValue(row, CONFIG.COLUMNS.KAR_ZARAR_TL),
          karZararUSD: this._getNumericValue(row, CONFIG.COLUMNS.KAR_ZARAR_USD),
          karZararEUR: this._getNumericValue(row, CONFIG.COLUMNS.KAR_ZARAR_EUR),
          karZararYuzde: this._getNumericValue(row, CONFIG.COLUMNS.KAR_ZARAR_YUZDE),
          karZararAltin: this._getNumericValue(row, CONFIG.COLUMNS.KAR_ZARAR_ALTIN),

          // ==================== DURUM / GÃœNCELLEME ====================
          fiyatGuncelleme: this._parseDate(this._getValue(row, CONFIG.COLUMNS.FIYAT_GUNCELLEME)),
          durum: this._getValue(row, CONFIG.COLUMNS.DURUM),
          gunlukDegisim: this._getNumericValue(row, CONFIG.COLUMNS.GUNLUK_DEGISIM),
          gunlukDegisimTL: this._getNumericValue(row, CONFIG.COLUMNS.GUNLUK_DEGISIM_TL),

          // ==================== PORTFÃ–Y AÄIRLIK ====================
          portfoyAgirlik: this._getNumericValue(row, CONFIG.COLUMNS.PORTFOY_AGIRLIK),
          kategoriAgirlik: this._getNumericValue(row, CONFIG.COLUMNS.KATEGORI_AGIRLIK),

          // ==================== MALÄ°YET / GETÄ°RÄ° ====================
          ortalamaMaliyet: this._getNumericValue(row, CONFIG.COLUMNS.ORTALAMA_MALIYET),
          tutulmaSuresi: this._getNumericValue(row, CONFIG.COLUMNS.TUTULMA_SURESI),
          getiriYillik: this._getNumericValue(row, CONFIG.COLUMNS.GETIRI_YILLIK),

          // ==================== TEKNÄ°K ANALÄ°Z ====================
          rsi14: this._getNumericValue(row, CONFIG.COLUMNS.RSI_14),
          movingAverage50: this._getNumericValue(row, CONFIG.COLUMNS.MOVING_AVERAGE_50),

          // ==================== ALARM ====================
          alarmSeviyesi: this._getValue(row, CONFIG.COLUMNS.ALARM_SEVIYESI),
          hedefFiyat: this._getNumericValue(row, CONFIG.COLUMNS.HEDEF_FIYAT),
          stopLoss: this._getNumericValue(row, CONFIG.COLUMNS.STOP_LOSS),

          // ==================== METADATA ====================
          notlar: this._getValue(row, CONFIG.COLUMNS.NOTLAR),
          etiketler: this._getValue(row, CONFIG.COLUMNS.ETIKETLER),
          hesaplamaTarihi: this._parseDate(this._getValue(row, CONFIG.COLUMNS.HESAPLAMA_TARIHI)),
          veriKaynagi: this._getValue(row, CONFIG.COLUMNS.VERI_KAYNAGI),
        };

        // BoÅŸ satÄ±rlarÄ± filtrele (tÃ¼m alanlar boÅŸsa)
        const isEmpty = Object.values(obj).every(value => 
          value === undefined || value === null || value === '' || 
          (typeof value === 'number' && isNaN(value)) ||
          value === obj.__rawRow || value === obj.__rowNumber // Ã–zel alanlarÄ± hariÃ§ tut
        );

        return isEmpty ? null : obj;

      } catch (error) {
        console.error(`âŒ SatÄ±r ${rowIndex + 1} dÃ¶nÃ¼ÅŸtÃ¼rÃ¼lÃ¼rken hata:`, error);
        return null;
      }
    }).filter(item => item !== null); // null'larÄ± filtrele
  },

  /**
   * SatÄ±rdan deÄŸer al (gÃ¼venli)
   */
  _getValue(row, index) {
    if (!row || index < 0 || index >= row.length) {
      return '';
    }
    
    const value = row[index];
    
    // Null/undefined kontrolÃ¼
    if (value === null || value === undefined) {
      return '';
    }
    
    // String'e Ã§evir ve trim yap
    return value.toString().trim();
  },

 _getNumericValue(row, index) {
  if (!row || index < 0 || index >= row.length) return 0;

  const rawValue = row[index];
  if (rawValue === null || rawValue === undefined || rawValue === '') {
    return this._parseOptions && this._parseOptions.numericEmptyAsNull ? null : 0;
  }
  if (typeof rawValue === 'number') return Number.isFinite(rawValue) ? rawValue : 0;

  const str = rawValue.toString().trim();
  if (str === '') return 0;

  let cleanStr = str.replace(/\s/g, '');

  // TÃ¼rkÃ§e binlik/ondalÄ±k: 1.234,56
  if (/^[-+]?\d{1,3}(\.\d{3})*(,\d+)?$/.test(cleanStr)) {
    cleanStr = cleanStr.replace(/\./g, '').replace(',', '.');
    const num = parseFloat(cleanStr);
    return Number.isNaN(num) ? 0 : num;
  }

  // Ä°ngilizce binlik/ondalÄ±k: 1,234.56
  if (/^[-+]?\d{1,3}(,\d{3})*(\.\d+)?$/.test(cleanStr)) {
    cleanStr = cleanStr.replace(/,/g, '');
    const num = parseFloat(cleanStr);
    return Number.isNaN(num) ? 0 : num;
  }

  // Basit ondalÄ±k: 1234.56 / 30.67
  if (/^[-+]?\d+\.\d+$/.test(cleanStr)) {
    const num = parseFloat(cleanStr);
    return Number.isNaN(num) ? 0 : num;
  }

  // VirgÃ¼llÃ¼ basit ondalÄ±k: 30,67
  if (/^[-+]?\d+,\d+$/.test(cleanStr)) {
    cleanStr = cleanStr.replace(',', '.');
    const num = parseFloat(cleanStr);
    return Number.isNaN(num) ? 0 : num;
  }

  // Tam sayÄ±
  if (/^[-+]?\d+$/.test(cleanStr)) {
    const num = parseFloat(cleanStr);
    return Number.isNaN(num) ? 0 : num;
  }

  console.warn(`âš ï¸ SayÄ±ya Ã§evrilemedi: "${str}"`);
  return 0;
 },


  /**
   * Tarihi parse et
   */
  _parseDate(input) {
    if (!input) {
      return null;
    }
    
    // Zaten Date objesiyse
    if (input instanceof Date) {
      // GeÃ§erli bir tarih mi?
      if (isNaN(input.getTime())) {
        return null;
      }
      return input;
    }
    
    const str = input.toString().trim();
    
    // BoÅŸsa null dÃ¶ndÃ¼r
    if (str === '') {
      return null;
    }
    
    try {
      // "DD.MM.YYYY" formatÄ±
      const parts = str.split('.');
      if (parts.length === 3) {
        const day = parseInt(parts[0], 10);
        const month = parseInt(parts[1], 10) - 1; // Ay 0'dan baÅŸlar
        const year = parseInt(parts[2], 10);
        
        if (!isNaN(day) && !isNaN(month) && !isNaN(year)) {
          const fullYear = year < 100 ? 2000 + year : year;
          return new Date(fullYear, month, day);
        }
      }
      
      // "YYYY-MM-DD" formatÄ±
      const isoParts = str.split('-');
      if (isoParts.length === 3) {
        const year = parseInt(isoParts[0], 10);
        const month = parseInt(isoParts[1], 10) - 1;
        const day = parseInt(isoParts[2], 10);
        
        if (!isNaN(day) && !isNaN(month) && !isNaN(year)) {
          return new Date(year, month, day);
        }
      }
      
      // VarsayÄ±lan Date parser
      const date = new Date(str);
      
      // GeÃ§erli bir tarih mi?
      if (isNaN(date.getTime())) {
        console.warn(`âš ï¸ GeÃ§ersiz tarih formatÄ±: "${str}"`);
        return null;
      }
      
      return date;
      
    } catch (error) {
      console.error(`âŒ Tarih parse hatasÄ±: "${str}"`, error);
      return null;
    }
  },

  /**
   * Sheet'teki sÃ¼tun baÅŸlÄ±klarÄ±nÄ± getir (debug iÃ§in)
   */
  getColumnHeaders() {
    try {
      const sheet = this._getPortfolioSheet();
      if (!sheet) {
        return [];
      }
      
      // Ä°lk satÄ±rÄ± oku (baÅŸlÄ±klar)
      const headers = sheet.getRange(1, 1, 1, sheet.getLastColumn()).getValues()[0];
      
      console.log('ğŸ“‹ SÃ¼tun baÅŸlÄ±klarÄ±:');
      headers.forEach((header, index) => {
        console.log(`  ${index}. ${header} -> CONFIG.COLUMNS'da: ${this._getConfigColumnName(index)}`);
      });
      
      return headers;
      
    } catch (error) {
      console.error('âŒ BaÅŸlÄ±k okuma hatasÄ±:', error);
      return [];
    }
  },

  /**
   * CONFIG.COLUMNS'tan sÃ¼tun adÄ±nÄ± bul
   */
  _getConfigColumnName(index) {
    for (const [key, value] of Object.entries(CONFIG.COLUMNS)) {
      if (value === index) {
        return key;
      }
    }
    return 'TANIMSIZ';
  },

  /**
   * PortfÃ¶y verisini dÄ±ÅŸa aktar (baÅŸka dosyalar iÃ§in)
   */
  exportPortfolioData() {
    return this.readPortfolio();
  },

  /**
   * Belirli bir alanÄ±n deÄŸerlerini dÃ¶ndÃ¼r
   */
  getFieldValues(fieldName) {
    const portfolio = this.readPortfolio();
    return portfolio.map(item => item[fieldName]);
  },

  /**
   * Benzersiz deÄŸerleri dÃ¶ndÃ¼r
   */
  getUniqueValues(fieldName) {
    const values = this.getFieldValues(fieldName);
    return [...new Set(values.filter(val => val && val !== ''))];
  }
};
/**
 * ==================== DATAREADER TEST YARDIMCILARI ====================
 */
function _drNormalizeCompare(value) {
  if (value === null || value === undefined) return '';
  if (value instanceof Date) return value.getTime();
  if (typeof value === 'number') return Number.isFinite(value) ? Number(value.toFixed(8)) : '';

  const str = String(value).trim();
  if (str === '') return '';

  const compact = str.replace(/\s/g, '');
  const maybeNumber = Number(compact.replace(',', '.'));
  if (!Number.isNaN(maybeNumber) && /^[-+]?\d+(?:[\.,]\d+)?$/.test(compact)) {
    return Number(maybeNumber.toFixed(8));
  }

  return str;
}

function _drValuesEquivalent(rawValue, parsedValue, fieldType) {
  if (fieldType === 'numeric') {
    const rawEmpty = rawValue === '' || rawValue === null || rawValue === undefined;
    if (rawEmpty && (parsedValue === 0 || parsedValue === null)) return true;
  }
  return rawValue === parsedValue;
}

function _drSideBySideValue(rawValue, parsedValue) {
  return `raw="${rawValue}" | parsed="${parsedValue}"`;
}

function _drCountNonEmptyRawColumn(rows, colIndex) {
  if (!Array.isArray(rows) || rows.length === 0) return 0;

  let count = 0;
  rows.forEach(item => {
    const row = item && item.__rawRow;
    if (!Array.isArray(row)) return;
    const value = row[colIndex];
    if (value !== '' && value !== null && value !== undefined) {
      count++;
    }
  });

  return count;
}

function _drFindLatestRecord(records) {
  if (!Array.isArray(records) || records.length === 0) return null;
  return [...records].sort((a, b) => {
    const tA = a && a.date ? new Date(a.date).getTime() : 0;
    const tB = b && b.date ? new Date(b.date).getTime() : 0;
    return tB - tA;
  })[0] || null;
}

function _drFindLatestBySymbol(records, symbol) {
  if (!Array.isArray(records) || records.length === 0) return null;
  const search = String(symbol || '').trim().toLowerCase();
  const filtered = records.filter(item => String(item && item.symbol ? item.symbol : '').trim().toLowerCase() === search);
  return _drFindLatestRecord(filtered);
}

function _drAgeInDays(dateValue) {
  if (!dateValue) return Infinity;
  const time = new Date(dateValue).getTime();
  if (isNaN(time)) return Infinity;
  return (Date.now() - time) / (24 * 60 * 60 * 1000);
}

/**
 * âœ… TEST 1: Ham veri -> parse edilen obje tutarlÄ±lÄ±ÄŸÄ±
 *
 * AmaÃ§:
 * - PortfÃ¶y satÄ±rlarÄ± iÃ§in kritik alanlarda ham hÃ¼cre deÄŸeri ile objeye yazÄ±lan alanlarÄ± karÅŸÄ±laÅŸtÄ±rmak
 * - Numeric alanlarda "" ve 0'Ä± eÅŸdeÄŸer kabul ederek false-positive farklarÄ± azaltmak
 * - Test sonunda ham/parsed deÄŸerleri yan yana gÃ¶steren bir Ã¶zet basmak
 */
function test_DataReader_RawVsParsedConsistency(options) {
  const opts = options || {};
  const limit = opts.limit || 50;
  const previewRows = opts.previewRows || 5;
  const forceRefresh = opts.forceRefresh === true;

  console.log('ğŸ§ª TEST 1 - HAM VERÄ° / PARSED VERÄ° TUTARLILIK KONTROLÃœ');
  console.log('='.repeat(90));

  const compareFields = [
    { key: 'id', col: CONFIG.COLUMNS.ID, type: 'text' },
    { key: 'baslik', col: CONFIG.COLUMNS.BASLIK, type: 'text' },
    { key: 'kategori', col: CONFIG.COLUMNS.KATEGORI, type: 'text' },
    { key: 'birimi', col: CONFIG.COLUMNS.BIRIMI, type: 'text' },
    { key: 'adet', col: CONFIG.COLUMNS.ADET, type: 'numeric' },
    { key: 'birimFiyat', col: CONFIG.COLUMNS.BIRIM_FIYAT, type: 'numeric' },
    { key: 'yatirilanTutar', col: CONFIG.COLUMNS.YATIRILAN_TUTAR, type: 'numeric' },
    { key: 'guncelTutar', col: CONFIG.COLUMNS.GUNCEL_TUTAR, type: 'numeric' }
  ];

  try {
    const sheet = DataReader._getPortfolioSheet();
    if (!sheet) {
      console.error('âŒ PortfÃ¶y sheet bulunamadÄ±');
      return { success: false, reason: 'sheet-not-found' };
    }

    const rawRows = DataReader._readAllData(sheet);
    const parsedRows = DataReader.readPortfolio(forceRefresh);

    const rowCount = Math.min(limit, rawRows.length, parsedRows.length);
    const mismatches = [];

    for (let i = 0; i < rowCount; i++) {
      const raw = rawRows[i];
      const parsed = parsedRows[i];
      if (!parsed) continue;

      compareFields.forEach(field => {
        const rawValue = _drNormalizeCompare(raw[field.col]);
        const parsedValue = _drNormalizeCompare(parsed[field.key]);

        if (!_drValuesEquivalent(rawValue, parsedValue, field.type)) {
          mismatches.push({
            rowNumber: CONFIG.SHEETS.PORTFOY.FIRST_DATA_ROW + i,
            field: field.key,
            rawValue: rawValue,
            parsedValue: parsedValue
          });
        }
      });
    }

    console.log(`ğŸ“Š Kontrol edilen satÄ±r: ${rowCount}`);
    console.log(`ğŸ“Š Kontrol edilen alan/satÄ±r: ${compareFields.length}`);
    console.log(`â— Toplam fark: ${mismatches.length}`);

    if (mismatches.length > 0) {
      console.log('ğŸ” Ä°lk 20 fark:');
      mismatches.slice(0, 20).forEach((m, idx) => {
        console.log(`${idx + 1}. satÄ±r=${m.rowNumber} alan=${m.field} | ${_drSideBySideValue(m.rawValue, m.parsedValue)}`);
      });
    } else {
      console.log('âœ… Ham veri ile parse edilen veri tutarlÄ± gÃ¶rÃ¼nÃ¼yor.');
    }

    const previewCount = Math.min(previewRows, rowCount);
    console.log('\nğŸ“Œ HAM vs PARSED Ã–NÄ°ZLEME (YAN YANA):');
    for (let i = 0; i < previewCount; i++) {
      const raw = rawRows[i];
      const parsed = parsedRows[i] || {};
      const rowNo = CONFIG.SHEETS.PORTFOY.FIRST_DATA_ROW + i;
      console.log(`\n   SatÄ±r ${rowNo}:`);
      compareFields.forEach(field => {
        const rawValue = _drNormalizeCompare(raw[field.col]);
        const parsedValue = _drNormalizeCompare(parsed[field.key]);
        console.log(`   - ${field.key}: ${_drSideBySideValue(rawValue, parsedValue)}`);
      });
    }

    return {
      success: mismatches.length === 0,
      checkedRows: rowCount,
      checkedFields: compareFields.length,
      mismatchCount: mismatches.length,
      mismatches: mismatches
    };

  } catch (error) {
    console.error('âŒ TEST 1 hata:', error);
    return { success: false, error: error.message };
  } finally {
    console.log('='.repeat(90));
  }
}

/**
 * âœ… TEST 2: Cache'e basÄ±lan payload doÄŸrulamasÄ±
 *
 * AmaÃ§:
 * - PortfÃ¶y/hisse/dÃ¶viz/altÄ±n verisi cache'e gerÃ§ekten yazÄ±lÄ±yor mu?
 * - Cache'teki ilk kayÄ±t ile ilgili okuyucu fonksiyonunun ilk kaydÄ± tutarlÄ± mÄ±?
 * - Cache zaman damgalarÄ± oluÅŸuyor mu?
 */
function test_DataReader_CachePayloadIntegrity(options) {
  const opts = options || {};
  const forceRefresh = opts.forceRefresh !== false; // default true
  const includeAllRecords = opts.includeAllRecords === true;
  const recordLimit = opts.recordLimit || 10;
  const freshnessDays = opts.freshnessDays || 3;

  console.log('ğŸ§ª TEST 2 - CACHE PAYLOAD BÃœTÃœNLÃœK KONTROLÃœ');
  console.log('='.repeat(90));

  try {
    DataReader.clearCache();

    const portfolio = DataReader.readPortfolio(forceRefresh);
    const stocks = DataReader.readHistoricalStockPrices(forceRefresh);
    const currencies = DataReader.readHistoricalCurrencyPrices(forceRefresh);
    const golds = DataReader.readHistoricalGoldPrices(forceRefresh);

    const checks = [
      {
        label: 'portfolio',
        loaded: portfolio,
        cache: DataReader._cache.portfolio,
        lastFetch: DataReader._cache.lastFetchPortfolio
      },
      {
        label: 'historicalSTOCK',
        loaded: stocks,
        cache: DataReader._cache.historicalSTOCK,
        lastFetch: DataReader._cache.lastFetchSTOCK
      },
      {
        label: 'historicalCURRENCY',
        loaded: currencies,
        cache: DataReader._cache.historicalCURRENCY,
        lastFetch: DataReader._cache.lastFetchCURRENCY
      },
      {
        label: 'historicalGOLD',
        loaded: golds,
        cache: DataReader._cache.historicalGOLD,
        lastFetch: DataReader._cache.lastFetchGOLD
      }
    ];

    const issues = [];

    checks.forEach(item => {
      const loadedCount = Array.isArray(item.loaded) ? item.loaded.length : 0;
      const cacheCount = Array.isArray(item.cache) ? item.cache.length : 0;
      const hasTimestamp = item.lastFetch instanceof Date && !isNaN(item.lastFetch.getTime());

      console.log(`ğŸ“¦ ${item.label}: loaded=${loadedCount}, cache=${cacheCount}, timestamp=${hasTimestamp ? 'OK' : 'YOK'}`);

      if (loadedCount !== cacheCount) {
        issues.push(`${item.label}: loaded/cache count farklÄ± (${loadedCount}/${cacheCount})`);
      }

      if (!hasTimestamp) {
        issues.push(`${item.label}: lastFetch timestamp yok`);
      }

      if (loadedCount > 0 && cacheCount > 0) {
        const loadedFirst = _drNormalizeCompare(JSON.stringify(item.loaded[0]));
        const cacheFirst = _drNormalizeCompare(JSON.stringify(item.cache[0]));
        if (loadedFirst !== cacheFirst) {
          issues.push(`${item.label}: ilk kayÄ±t loaded/cache farklÄ±`);
        }
      }
    });

    console.log(`\nâ— Toplam issue: ${issues.length}`);
    if (issues.length > 0) {
      issues.forEach((msg, idx) => console.log(`${idx + 1}. ${msg}`));
    } else {
      console.log('âœ… Cache payload ve zaman damgalarÄ± tutarlÄ± gÃ¶rÃ¼nÃ¼yor.');
    }

    console.log('\nğŸ“Œ DB\'DEN OKUNUP CACHE\'E YAZILAN KAYITLAR (YAN YANA):');
    checks.forEach(item => {
      const loadedRows = Array.isArray(item.loaded) ? item.loaded : [];
      const cacheRows = Array.isArray(item.cache) ? item.cache : [];
      const printCount = includeAllRecords
        ? Math.min(loadedRows.length, cacheRows.length)
        : Math.min(recordLimit, loadedRows.length, cacheRows.length);

      console.log(`\n   ğŸ”¹ ${item.label} | yazdÄ±rÄ±lan kayÄ±t: ${printCount}/${cacheRows.length}`);
      for (let i = 0; i < printCount; i++) {
        const loadedJson = JSON.stringify(loadedRows[i]);
        const cacheJson = JSON.stringify(cacheRows[i]);
        console.log(`   ${i + 1}. loaded=${loadedJson}`);
        console.log(`      cache =${cacheJson}`);
      }
    });

    console.log('\nğŸ“Œ PORTFÃ–Y KOLON DOLULUK KONTROLÃœ (DB RAW ROW ÃœZERÄ°NDEN):');
    const portfolioCache = Array.isArray(DataReader._cache.portfolio) ? DataReader._cache.portfolio : [];
    const trackedColumns = [
      ['ID', CONFIG.COLUMNS.ID],
      ['TARIH', CONFIG.COLUMNS.TARIH],
      ['ISLEM_TURU', CONFIG.COLUMNS.ISLEM_TURU],
      ['BIRIMI', CONFIG.COLUMNS.BIRIMI],
      ['BIRIM_FIYAT', CONFIG.COLUMNS.BIRIM_FIYAT],
      ['BASLIK', CONFIG.COLUMNS.BASLIK],
      ['ADET', CONFIG.COLUMNS.ADET],
      ['KATEGORI', CONFIG.COLUMNS.KATEGORI],
      ['YATIRILAN_TUTAR', CONFIG.COLUMNS.YATIRILAN_TUTAR],
      ['GUNCEL_TUTAR', CONFIG.COLUMNS.GUNCEL_TUTAR],
      ['KAR_ZARAR_TUTAR', CONFIG.COLUMNS.KAR_ZARAR_TUTAR],
      ['VERI_KAYNAGI', CONFIG.COLUMNS.VERI_KAYNAGI]
    ];

    trackedColumns.forEach(([name, index]) => {
      const nonEmptyCount = _drCountNonEmptyRawColumn(portfolioCache, index);
      console.log(`   - ${name} (index=${index}): dolu=${nonEmptyCount}/${portfolioCache.length}`);
    });

    console.log('\nğŸ“Œ DÃ–VÄ°Z GÃœNCELLÄ°K KONTROLÃœ (LATEST BY SYMBOL):');
    const latestUsd = _drFindLatestBySymbol(currencies, 'USDTRY=X');
    const latestEur = _drFindLatestBySymbol(currencies, 'EURTRY=X');
    const latestCurrencyAny = _drFindLatestRecord(currencies);

    const latestRows = [
      ['USDTRY=X', latestUsd],
      ['EURTRY=X', latestEur],
      ['ANY_CURRENCY_LATEST', latestCurrencyAny]
    ];

    const freshnessWarnings = [];
    latestRows.forEach(([label, row]) => {
      if (!row) {
        const warn = `âš ï¸ ${label}: kayÄ±t bulunamadÄ±`;
        freshnessWarnings.push(warn);
        console.warn(warn);
        return;
      }

      const ageDays = _drAgeInDays(row.date);
      const dateIso = row.date ? new Date(row.date).toISOString() : 'YOK';
      const price = row.close !== undefined ? row.close : row.price;
      console.log(`   - ${label}: date=${dateIso}, ageDays=${ageDays.toFixed(2)}, price=${price}`);

      if (ageDays > freshnessDays) {
        const warn = `âš ï¸ ${label} gÃ¼ncellik alarmÄ±: ${ageDays.toFixed(2)} gÃ¼n (eÅŸik=${freshnessDays})`;
        freshnessWarnings.push(warn);
        console.warn(warn);
      }
    });

    return {
      success: issues.length === 0,
      issues: issues,
      freshnessWarnings: freshnessWarnings,
      snapshot: {
        portfolio: DataReader._cache.portfolio ? DataReader._cache.portfolio.length : 0,
        historicalSTOCK: DataReader._cache.historicalSTOCK ? DataReader._cache.historicalSTOCK.length : 0,
        historicalCURRENCY: DataReader._cache.historicalCURRENCY ? DataReader._cache.historicalCURRENCY.length : 0,
        historicalGOLD: DataReader._cache.historicalGOLD ? DataReader._cache.historicalGOLD.length : 0
      }
    };

  } catch (error) {
    console.error('âŒ TEST 2 hata:', error);
    return { success: false, error: error.message };
  } finally {
    console.log('='.repeat(90));
  }
}
