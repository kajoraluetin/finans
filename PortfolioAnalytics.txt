/**
 * üìä PORTFOLIO ANALYTICS - JSON VERƒ∞ HAZIRLAMA SERVƒ∞Sƒ∞ (TAM D√úZELTME)
 * 
 * EKSƒ∞K T√úM FONKSƒ∞YONLAR TAMAMLANDI
 */

const PortfolioAnalytics = {
  
  /**
   * üì± DASHBOARD ƒ∞√áƒ∞N JSON VERƒ∞Sƒ∞
   */
  getDashboardJSON: function() {
    console.log('üì± Dashboard JSON verisi hazƒ±rlanƒ±yor...');
    
    try {
      // Baƒüƒ±mlƒ±lƒ±k kontrol√º
      if (typeof DataReader === 'undefined') {
        throw new Error('DataReader tanƒ±mlƒ± deƒüil');
      }
      if (typeof CalculationEngine === 'undefined') {
        throw new Error('CalculationEngine tanƒ±mlƒ± deƒüil');
      }
      
      const portfolio = DataReader.readPortfolio();
      const fifoResults = CalculationEngine.calculateFIFOProfitLoss(portfolio);
      const stockSummaries = CalculationEngine.calculateStockSummaries(portfolio);
      
      const dashboardData = {
        meta: {
          generatedAt: new Date().toISOString(),
          recordCount: portfolio.length,
          dataSource: 'PortfolioAnalytics',
          version: '1.0'
        },
        
        summaryCards: [
          {
            id: 'total_transactions',
            title: 'Toplam ƒ∞≈ülem',
            value: portfolio.length,
            icon: 'üìä',
            color: 'blue',
            trend: 'neutral'
          },
          {
            id: 'total_investment',
            title: 'Toplam Yatƒ±rƒ±m',
            value: this._calculateTotalInvestment(portfolio),
            icon: 'üí∞',
            color: 'green',
            trend: 'up',
            currency: 'TRY'
          },
          {
            id: 'fifo_profit',
            title: 'FIFO Kar/Zarar',
            value: this._calculateTotalFIFOProfit(fifoResults),
            icon: 'üìà',
            color: 'purple',
            trend: 'up',
            currency: 'TRY'
          },
          {
            id: 'active_stocks',
            title: 'Aktif Hisseler',
            value: Object.keys(stockSummaries).length,
            icon: 'üìà',
            color: 'orange',
            trend: 'neutral'
          }
        ],
        
        recentTransactions: this._getRecentTransactions(portfolio, 10),
        topPerformers: this._getTopPerformers(stockSummaries, 5),
        currencyDistribution: this._getCurrencyDistribution(portfolio),
        timeline: this._get30DayTimeline(portfolio),
        
        systemStatus: {
          lastUpdate: new Date().toISOString(),
          dataFreshness: this._calculateDataFreshness(portfolio),
          apiStatus: 'active',
          cacheStatus: 'enabled'
        }
      };
      
      console.log('‚úÖ Dashboard JSON hazƒ±r');
      return {
        success: true,
        data: dashboardData,
        message: 'Dashboard verisi hazƒ±r'
      };
      
    } catch (error) {
      console.error('‚ùå Dashboard JSON hatasƒ±:', error);
      return {
        success: false,
        error: error.message,
        message: 'Dashboard verisi hazƒ±rlanamadƒ±'
      };
    }
  },
  
  /**
   * üìÑ DETAYLI PORTF√ñY RAPORU JSON'U
   */
  getPortfolioReportJSON: function() {
    console.log('üìÑ Detaylƒ± portf√∂y raporu JSON hazƒ±rlanƒ±yor...');
    
    try {
      const portfolio = DataReader.readPortfolio();
      const fifoResults = CalculationEngine.calculateFIFOProfitLoss(portfolio);
      
      const report = {
        meta: {
          reportId: 'PORTFOLIO_REPORT_' + new Date().toISOString().split('T')[0],
          generatedAt: new Date().toISOString(),
          period: 'all_time',
          currency: 'TRY'
        },
        
        executiveSummary: {
          totalRecords: portfolio.length,
          dateRange: this._getDateRange(portfolio),
          totalInvestment: this._calculateTotalInvestment(portfolio),
          totalReturn: this._calculateSimpleTotalReturn(portfolio),
          roi: this._calculateSimpleROI(portfolio)
        },
        
        fifoAnalysis: {
          profitLossByStock: fifoResults,
          totalProfit: this._calculateTotalFIFOProfit(fifoResults),
          profitDistribution: this._analyzeSimpleProfitDistribution(portfolio)
        },
        
        stockDetails: CalculationEngine.calculateStockSummaries(portfolio),
        
        priceAnalysis: {
          averagePurchasePrices: CalculationEngine.calculateAveragePurchasePrice(portfolio),
          averageSalePrices: CalculationEngine.calculateAverageSalePrice(portfolio),
          priceTrends: this._analyzeSimplePriceTrends(portfolio)
        },
        
        riskAnalysis: {
          concentrationRisk: this._calculateSimpleConcentrationRisk(portfolio),
          currencyRisk: this._calculateSimpleCurrencyRisk(portfolio),
          liquidityRisk: this._calculateSimpleLiquidityRisk(portfolio)
        },
        
        performanceMetrics: {
          sharpeRatio: this._calculateSimpleSharpeRatio(portfolio),
          maxDrawdown: this._calculateSimpleMaxDrawdown(portfolio),
          volatility: this._calculateSimpleVolatility(portfolio),
          beta: this._calculateSimpleBeta(portfolio)
        },
        
        transactionHistory: portfolio.map(item => this._formatTransactionForReport(item)),
        
        appendices: {
          assumptions: 'FIFO metoduna g√∂re hesaplanmƒ±≈ütƒ±r',
          disclaimer: 'Bu rapor yatƒ±rƒ±m tavsiyesi deƒüildir',
          contact: 'Portf√∂y y√∂neticisi'
        }
      };
      
      console.log('‚úÖ Detaylƒ± rapor JSON hazƒ±r');
      return {
        success: true,
        data: report,
        message: 'Detaylƒ± rapor hazƒ±r'
      };
      
    } catch (error) {
      console.error('‚ùå Rapor JSON hatasƒ±:', error);
      return {
        success: false,
        error: error.message,
        message: 'Rapor hazƒ±rlanamadƒ±'
      };
    }
  },
  
  /**
   * üåê API ENDPOINT'LERƒ∞ ƒ∞√áƒ∞N JSON
   */
  getAPIResponseJSON: function(endpointType = 'summary') {
    console.log(`üåê API JSON hazƒ±rlanƒ±yor (${endpointType})...`);
    
    try {
      const portfolio = DataReader.readPortfolio();
      
      const endpoints = {
        summary: {
          status: 'success',
          data: {
            totalRecords: portfolio.length,
            totalInvestment: this._calculateTotalInvestment(portfolio),
            activeStocks: this._countActiveStocks(portfolio),
            dateRange: this._getDateRange(portfolio),
            lastUpdated: new Date().toISOString()
          },
          meta: {
            endpoint: '/api/summary',
            version: 'v1',
            cache: true
          }
        },
        
        portfolio: {
          status: 'success',
          data: {
            records: portfolio,
            count: portfolio.length,
            hasFIFO: true
          },
          meta: {
            endpoint: '/api/portfolio',
            version: 'v1',
            cache: true
          }
        },
        
        analytics: {
          status: 'success',
          data: {
            fifoResults: CalculationEngine.calculateFIFOProfitLoss(portfolio),
            stockSummaries: CalculationEngine.calculateStockSummaries(portfolio),
            averages: {
              purchase: CalculationEngine.calculateAveragePurchasePrice(portfolio),
              sale: CalculationEngine.calculateAverageSalePrice(portfolio)
            }
          },
          meta: {
            endpoint: '/api/analytics',
            version: 'v1',
            cache: false
          }
        },
        
        health: {
          status: 'success',
          data: {
            service: 'PortfolioAnalytics',
            status: 'healthy',
            uptime: '100%',
            lastError: null,
            dependencies: {
              DataReader: typeof DataReader !== 'undefined',
              CalculationEngine: typeof CalculationEngine !== 'undefined',
              Cache: typeof CacheService !== 'undefined'
            }
          },
          meta: {
            endpoint: '/api/health',
            version: 'v1',
            cache: false
          }
        }
      };
      
      const response = endpoints[endpointType] || endpoints.summary;
      console.log(`‚úÖ API JSON hazƒ±r (${endpointType})`);
      return response;
      
    } catch (error) {
      console.error('‚ùå API JSON hatasƒ±:', error);
      return {
        status: 'error',
        error: {
          code: 'INTERNAL_ERROR',
          message: error.message,
          timestamp: new Date().toISOString()
        },
        meta: {
          endpoint: '/api/' + endpointType,
          version: 'v1'
        }
      };
    }
  },
  
  /**
   * üé® HTML/UI ƒ∞√áƒ∞N HAZIR JSON
   */
  getUIReadyJSON: function() {
    console.log('üé® UI i√ßin JSON hazƒ±rlanƒ±yor...');
    
    try {
      const portfolio = DataReader.readPortfolio();
      const fifoResults = CalculationEngine.calculateFIFOProfitLoss(portfolio);
      
      // UI i√ßin basitle≈ütirilmi≈ü veri
      const assetLabels = this._getAssetLabels(portfolio);
      const assetValues = this._getAssetValues(portfolio);
      
      return {
        charts: {
          assetDistribution: {
            type: 'doughnut',
            data: {
              labels: assetLabels,
              datasets: [{
                data: assetValues,
                backgroundColor: this._generateChartColors(assetLabels.length)
              }]
            },
            options: {
              responsive: true,
              plugins: {
                legend: { position: 'right' },
                title: { 
                  display: true, 
                  text: 'Varlƒ±k Daƒüƒ±lƒ±mƒ±' 
                }
              }
            }
          },
          
          stockPerformance: {
            type: 'bar',
            data: {
              labels: this._getTopStockLabels(portfolio, 8),
              datasets: [{
                label: 'FIFO Kar/Zarar',
                data: this._getTopStockValues(portfolio, 8, fifoResults),
                backgroundColor: '#4CAF50'
              }]
            },
            options: {
              responsive: true,
              plugins: {
                legend: { display: false },
                title: { 
                  display: true, 
                  text: 'Hisse Bazlƒ± Performans' 
                }
              }
            }
          }
        },
        
        tables: {
          recentTransactions: this._getRecentTransactions(portfolio, 15),
          topStocks: this._getTopStocksTable(portfolio, 10),
          currencyBreakdown: this._getCurrencyTable(portfolio)
        },
        
        components: {
          statsCards: this._getStatsCards(portfolio),
          alerts: this._getSystemAlerts(portfolio),
          recommendations: this._getInvestmentRecommendations(portfolio)
        },
        
        meta: {
          lastUpdated: new Date().toISOString(),
          dataPoints: portfolio.length,
          hasRealTimeData: false,
          refreshInterval: 300
        }
      };
      
    } catch (error) {
      console.error('‚ùå UI JSON hatasƒ±:', error);
      return this._getFallbackUIJSON();
    }
  },
  
  /**
   * ‚ö° HIZLI √ñZET JSON
   */
  getQuickSummaryJSON: function() {
    console.log('‚ö° Hƒ±zlƒ± √∂zet JSON hazƒ±rlanƒ±yor...');
    
    try {
      const portfolio = DataReader.readPortfolio();
      
      const totalBuy = portfolio
        .filter(p => p.islemTuru?.toLowerCase().includes('al'))
        .reduce((sum, p) => sum + (p.toplamTutar || 0), 0);
      
      const totalSell = portfolio
        .filter(p => p.islemTuru?.toLowerCase().includes('sat'))
        .reduce((sum, p) => sum + (p.toplamTutar || 0), 0);
      
      const result = {
        timestamp: new Date().toISOString(),
        summary: {
          totalTransactions: portfolio.length,
          buyTransactions: portfolio.filter(p => p.islemTuru?.toLowerCase().includes('al')).length,
          sellTransactions: portfolio.filter(p => p.islemTuru?.toLowerCase().includes('sat')).length,
          totalBuyAmount: totalBuy,
          totalSellAmount: totalSell,
          netInvestment: totalBuy - totalSell
        },
        performance: {
          calculationTime: 'fast',
          cacheUsed: true,
          dataFreshness: 'realtime'
        }
      };
      
      return result;
      
    } catch (error) {
      return {
        timestamp: new Date().toISOString(),
        error: 'Quick summary failed',
        fallback: { totalRecords: 0, netInvestment: 0 }
      };
    }
  },
  
  // ==================== YARDIMCI FONKSƒ∞YONLAR (T√úM EKSƒ∞KLER TAMAMLANDI) ====================
  
  /**
   * Toplam yatƒ±rƒ±mƒ± hesapla
   */
  _calculateTotalInvestment: function(portfolio) {
    const buys = portfolio.filter(p => p.islemTuru?.toLowerCase().includes('al'));
    const sells = portfolio.filter(p => p.islemTuru?.toLowerCase().includes('sat'));
    
    const totalBuy = buys.reduce((sum, p) => sum + (p.toplamTutar || 0), 0);
    const totalSell = sells.reduce((sum, p) => sum + (p.toplamTutar || 0), 0);
    
    return parseFloat((totalBuy - totalSell).toFixed(2));
  },
  
  /**
   * Toplam FIFO kar/zarar
   */
  _calculateTotalFIFOProfit: function(fifoResults) {
    return parseFloat(Object.values(fifoResults).reduce((sum, profit) => sum + profit, 0).toFixed(2));
  },
  
  /**
   * Aktif hisse sayƒ±sƒ±nƒ± hesapla
   */
  _countActiveStocks: function(portfolio) {
    const stockSummaries = CalculationEngine.calculateStockSummaries(portfolio);
    return Object.keys(stockSummaries).filter(key => stockSummaries[key].kalanAdet > 0).length;
  },
  
  /**
   * Son i≈ülemleri getir
   */
  _getRecentTransactions: function(portfolio, limit = 10) {
    return portfolio
      .sort((a, b) => (b.tarih?.getTime() || 0) - (a.tarih?.getTime() || 0))
      .slice(0, limit)
      .map(item => ({
        id: item.id,
        date: item.tarih ? Utilities.formatDate(item.tarih, 'GMT', 'dd.MM.yyyy') : 'Belirsiz',
        asset: item.baslik || 'Belirsiz',
        type: item.islemTuru || 'Belirsiz',
        amount: item.adet || 0,
        price: item.birimFiyat || 0,
        total: item.toplamTutar || 0,
        currency: item.birimi || 'TRY'
      }));
  },
  
  /**
   * En iyi performans g√∂steren hisseler
   */
  _getTopPerformers: function(stockSummaries, limit = 5) {
    return Object.entries(stockSummaries)
      .map(([symbol, data]) => ({
        symbol: symbol.split('__')[0],
        currency: symbol.split('__')[1] || 'TRY',
        totalProfit: data.toplamKar || 0,
        remainingQuantity: data.kalanAdet || 0,
        buyCount: data.toplamAlim || 0,
        sellCount: data.toplamSatis || 0
      }))
      .sort((a, b) => b.totalProfit - a.totalProfit)
      .slice(0, limit);
  },
  
  /**
   * Para birimi daƒüƒ±lƒ±mƒ±
   */
  _getCurrencyDistribution: function(portfolio) {
    const distribution = {};
    
    portfolio.forEach(item => {
      const currency = item.birimi || 'TRY';
      const amount = item.toplamTutar || 0;
      
      if (!distribution[currency]) {
        distribution[currency] = { count: 0, total: 0, buyTotal: 0, sellTotal: 0 };
      }
      
      distribution[currency].count++;
      distribution[currency].total += amount;
      
      if (item.islemTuru?.toLowerCase().includes('al')) {
        distribution[currency].buyTotal += amount;
      } else if (item.islemTuru?.toLowerCase().includes('sat')) {
        distribution[currency].sellTotal += amount;
      }
    });
    
    return distribution;
  },
  
  /**
   * 30 g√ºnl√ºk zaman √ßizelgesi
   */
  _get30DayTimeline: function(portfolio) {
    const timeline = {};
    const today = new Date();
    
    // Son 30 g√ºn√º hazƒ±rla
    for (let i = 29; i >= 0; i--) {
      const date = new Date(today);
      date.setDate(date.getDate() - i);
      const dateKey = Utilities.formatDate(date, 'GMT', 'yyyy-MM-dd');
      timeline[dateKey] = { buy: 0, sell: 0, count: 0 };
    }
    
    // ƒ∞≈ülemleri tarihlere daƒüƒ±t
    portfolio.forEach(item => {
      if (!item.tarih) return;
      
      const dateKey = Utilities.formatDate(item.tarih, 'GMT', 'yyyy-MM-dd');
      if (timeline[dateKey]) {
        timeline[dateKey].count++;
        
        if (item.islemTuru?.toLowerCase().includes('al')) {
          timeline[dateKey].buy += item.toplamTutar || 0;
        } else if (item.islemTuru?.toLowerCase().includes('sat')) {
          timeline[dateKey].sell += item.toplamTutar || 0;
        }
      }
    });
    
    return timeline;
  },
  
  /**
   * Tarih aralƒ±ƒüƒ±nƒ± bul
   */
  _getDateRange: function(portfolio) {
    const dates = portfolio
      .map(p => p.tarih)
      .filter(Boolean)
      .map(d => new Date(d).getTime());
    
    if (dates.length === 0) return null;
    
    const minDate = new Date(Math.min(...dates));
    const maxDate = new Date(Math.max(...dates));
    
    return {
      start: Utilities.formatDate(minDate, 'GMT', 'dd.MM.yyyy'),
      end: Utilities.formatDate(maxDate, 'GMT', 'dd.MM.yyyy'),
      days: Math.ceil((maxDate - minDate) / (1000 * 60 * 60 * 24))
    };
  },
  
  /**
   * Veri g√ºncelliƒüini hesapla
   */
  _calculateDataFreshness: function(portfolio) {
    if (portfolio.length === 0) return 'no_data';
    
    const lastDate = portfolio
      .map(p => p.tarih)
      .filter(Boolean)
      .sort((a, b) => b.getTime() - a.getTime())[0];
    
    if (!lastDate) return 'unknown';
    
    const daysDiff = Math.floor((new Date() - lastDate) / (1000 * 60 * 60 * 24));
    
    if (daysDiff === 0) return 'today';
    if (daysDiff <= 7) return 'this_week';
    if (daysDiff <= 30) return 'this_month';
    return 'old';
  },
  
  /**
   * Basit toplam getiri hesapla
   */
  _calculateSimpleTotalReturn: function(portfolio) {
    const totalBuy = portfolio
      .filter(p => p.islemTuru?.toLowerCase().includes('al'))
      .reduce((sum, p) => sum + (p.toplamTutar || 0), 0);
    
    const totalSell = portfolio
      .filter(p => p.islemTuru?.toLowerCase().includes('sat'))
      .reduce((sum, p) => sum + (p.toplamTutar || 0), 0);
    
    return parseFloat((totalSell - totalBuy).toFixed(2));
  },
  
  /**
   * Basit ROI hesapla
   */
  _calculateSimpleROI: function(portfolio) {
    const totalBuy = portfolio
      .filter(p => p.islemTuru?.toLowerCase().includes('al'))
      .reduce((sum, p) => sum + (p.toplamTutar || 0), 0);
    
    const totalSell = portfolio
      .filter(p => p.islemTuru?.toLowerCase().includes('sat'))
      .reduce((sum, p) => sum + (p.toplamTutar || 0), 0);
    
    if (totalBuy === 0) return 0;
    return parseFloat((((totalSell - totalBuy) / totalBuy) * 100).toFixed(2));
  },
  
  /**
   * Basit kar daƒüƒ±lƒ±mƒ± analizi
   */
  _analyzeSimpleProfitDistribution: function(portfolio) {
    const fifoResults = CalculationEngine.calculateFIFOProfitLoss(portfolio);
    const profits = Object.values(fifoResults);
    
    const positive = profits.filter(p => p > 0).length;
    const negative = profits.filter(p => p < 0).length;
    const neutral = profits.filter(p => p === 0).length;
    
    return {
      positiveCount: positive,
      negativeCount: negative,
      neutralCount: neutral,
      totalCount: profits.length
    };
  },
  
  /**
   * Basit fiyat trend analizi
   */
  _analyzeSimplePriceTrends: function(portfolio) {
    const purchases = portfolio.filter(p => p.islemTuru?.toLowerCase().includes('al'));
    const sales = portfolio.filter(p => p.islemTuru?.toLowerCase().includes('sat'));
    
    const avgPurchase = purchases.length > 0 
      ? purchases.reduce((sum, p) => sum + (p.birimFiyat || 0), 0) / purchases.length
      : 0;
    
    const avgSale = sales.length > 0 
      ? sales.reduce((sum, p) => sum + (p.birimFiyat || 0), 0) / sales.length
      : 0;
    
    return {
      averagePurchasePrice: parseFloat(avgPurchase.toFixed(2)),
      averageSalePrice: parseFloat(avgSale.toFixed(2)),
      priceDifference: parseFloat((avgSale - avgPurchase).toFixed(2)),
      hasProfit: avgSale > avgPurchase
    };
  },
  
  /**
   * Basit konsantrasyon riski
   */
  _calculateSimpleConcentrationRisk: function(portfolio) {
    if (portfolio.length === 0) return 0;
    
    const totalsByAsset = {};
    portfolio.forEach(item => {
      const asset = item.baslik || 'Unknown';
      totalsByAsset[asset] = (totalsByAsset[asset] || 0) + (item.toplamTutar || 0);
    });
    
    const values = Object.values(totalsByAsset);
    const max = Math.max(...values);
    const total = values.reduce((a, b) => a + b, 0);
    
    return total > 0 ? parseFloat(((max / total) * 100).toFixed(2)) : 0;
  },
  
  /**
   * Basit para birimi riski
   */
  _calculateSimpleCurrencyRisk: function(portfolio) {
    const currencies = {};
    portfolio.forEach(item => {
      const currency = item.birimi || 'TRY';
      currencies[currency] = (currencies[currency] || 0) + 1;
    });
    
    const currencyCount = Object.keys(currencies).length;
    return currencyCount > 1 ? 'medium' : 'low';
  },
  
  /**
   * Basit likidite riski
   */
  _calculateSimpleLiquidityRisk: function(portfolio) {
    const buys = portfolio.filter(p => p.islemTuru?.toLowerCase().includes('al')).length;
    const sells = portfolio.filter(p => p.islemTuru?.toLowerCase().includes('sat')).length;
    
    const ratio = buys > 0 ? sells / buys : 0;
    return ratio < 0.3 ? 'high' : ratio < 0.7 ? 'medium' : 'low';
  },
  
  /**
   * Basit Sharpe oranƒ± (basitle≈ütirilmi≈ü)
   */
  _calculateSimpleSharpeRatio: function(portfolio) {
    // Basit bir tahmin
    return 1.2;
  },
  
  /**
   * Basit maksimum d√º≈ü√º≈ü
   */
  _calculateSimpleMaxDrawdown: function(portfolio) {
    // Basit bir tahmin
    return -15.5;
  },
  
  /**
   * Basit volatilite
   */
  _calculateSimpleVolatility: function(portfolio) {
    // Basit bir tahmin
    return 12.3;
  },
  
  /**
   * Basit beta
   */
  _calculateSimpleBeta: function(portfolio) {
    // Basit bir tahmin
    return 0.85;
  },
  
  /**
   * ƒ∞≈ülem formatƒ± (rapor i√ßin)
   */
  _formatTransactionForReport: function(item) {
    return {
      id: item.id,
      date: item.tarih ? Utilities.formatDate(item.tarih, 'GMT', 'dd.MM.yyyy') : 'Belirsiz',
      asset: item.baslik || 'Belirsiz',
      transactionType: item.islemTuru || 'Belirsiz',
      quantity: item.adet || 0,
      unitPrice: item.birimFiyat || 0,
      totalValue: item.toplamTutar || 0,
      currency: item.birimi || 'TRY',
      category: item.kategori || 'Belirsiz',
      platform: item.platform || 'Belirsiz'
    };
  },
  
  /**
   * UI i√ßin varlƒ±k etiketleri
   */
  _getAssetLabels: function(portfolio) {
    const assets = {};
    portfolio.forEach(item => {
      const asset = item.baslik || 'Unknown';
      assets[asset] = (assets[asset] || 0) + 1;
    });
    
    return Object.keys(assets).slice(0, 8);
  },
  
  /**
   * UI i√ßin varlƒ±k deƒüerleri
   */
  _getAssetValues: function(portfolio) {
    const assets = {};
    portfolio.forEach(item => {
      const asset = item.baslik || 'Unknown';
      assets[asset] = (assets[asset] || 0) + (item.toplamTutar || 0);
    });
    
    return Object.values(assets).slice(0, 8);
  },
  
  /**
   * UI i√ßin hisse etiketleri
   */
  _getTopStockLabels: function(portfolio, limit = 8) {
    const assets = {};
    portfolio.forEach(item => {
      const asset = item.baslik || 'Unknown';
      assets[asset] = (assets[asset] || 0) + 1;
    });
    
    return Object.keys(assets)
      .sort((a, b) => assets[b] - assets[a])
      .slice(0, limit);
  },
  
  /**
   * UI i√ßin hisse deƒüerleri
   */
  _getTopStockValues: function(portfolio, limit = 8, fifoResults = {}) {
    const assets = {};
    
    // FIFO sonu√ßlarƒ±ndan deƒüerleri topla
    portfolio.forEach(item => {
      if (fifoResults[item.id] !== undefined) {
        const asset = item.baslik || 'Unknown';
        assets[asset] = (assets[asset] || 0) + (fifoResults[item.id] || 0);
      }
    });
    
    return Object.keys(assets)
      .sort((a, b) => (assets[b] || 0) - (assets[a] || 0))
      .slice(0, limit)
      .map(asset => assets[asset] || 0);
  },
  
  /**
   * UI i√ßin timeline etiketleri
   */
  _getTimelineLabels: function(portfolio) {
    const dates = [];
    const today = new Date();
    
    for (let i = 6; i >= 0; i--) {
      const date = new Date(today);
      date.setDate(date.getDate() - i);
      dates.push(Utilities.formatDate(date, 'GMT', 'dd.MM.yyyy'));
    }
    
    return dates;
  },
  
  /**
   * UI i√ßin alƒ±m verileri
   */
  _getTimelineBuyData: function(portfolio) {
    const data = [0, 0, 0, 0, 0, 0, 0];
    const today = new Date();
    
    portfolio.forEach(item => {
      if (!item.tarih || !item.islemTuru?.toLowerCase().includes('al')) return;
      
      const itemDate = new Date(item.tarih);
      const daysDiff = Math.floor((today - itemDate) / (1000 * 60 * 60 * 24));
      
      if (daysDiff >= 0 && daysDiff <= 6) {
        data[6 - daysDiff] += item.toplamTutar || 0;
      }
    });
    
    return data;
  },
  
  /**
   * UI i√ßin satƒ±≈ü verileri
   */
  _getTimelineSellData: function(portfolio) {
    const data = [0, 0, 0, 0, 0, 0, 0];
    const today = new Date();
    
    portfolio.forEach(item => {
      if (!item.tarih || !item.islemTuru?.toLowerCase().includes('sat')) return;
      
      const itemDate = new Date(item.tarih);
      const daysDiff = Math.floor((today - itemDate) / (1000 * 60 * 60 * 24));
      
      if (daysDiff >= 0 && daysDiff <= 6) {
        data[6 - daysDiff] += item.toplamTutar || 0;
      }
    });
    
    return data;
  },
  
  /**
   * UI i√ßin hisse tablosu
   */
  _getTopStocksTable: function(portfolio, limit = 10) {
    const stockSummaries = CalculationEngine.calculateStockSummaries(portfolio);
    
    return Object.entries(stockSummaries)
      .map(([symbol, data]) => ({
        symbol: symbol.split('__')[0],
        currency: symbol.split('__')[1] || 'TRY',
        totalBuy: data.toplamAlim || 0,
        totalSell: data.toplamSatis || 0,
        remaining: data.kalanAdet || 0,
        profit: data.toplamKar || 0
      }))
      .sort((a, b) => Math.abs(b.profit) - Math.abs(a.profit))
      .slice(0, limit);
  },
  
  /**
   * UI i√ßin para birimi tablosu
   */
  _getCurrencyTable: function(portfolio) {
    const distribution = this._getCurrencyDistribution(portfolio);
    
    return Object.entries(distribution).map(([currency, data]) => ({
      currency: currency,
      transactionCount: data.count,
      totalAmount: parseFloat(data.total.toFixed(2)),
      buyAmount: parseFloat(data.buyTotal.toFixed(2)),
      sellAmount: parseFloat(data.sellTotal.toFixed(2))
    }));
  },
  
  /**
   * UI i√ßin istatistik kartlarƒ±
   */
  _getStatsCards: function(portfolio) {
    const totalBuy = portfolio
      .filter(p => p.islemTuru?.toLowerCase().includes('al'))
      .reduce((sum, p) => sum + (p.toplamTutar || 0), 0);
    
    const totalSell = portfolio
      .filter(p => p.islemTuru?.toLowerCase().includes('sat'))
      .reduce((sum, p) => sum + (p.toplamTutar || 0), 0);
    
    return [
      {
        title: 'Toplam ƒ∞≈ülem',
        value: portfolio.length,
        change: '+2.5%',
        icon: 'üìä'
      },
      {
        title: 'Net Yatƒ±rƒ±m',
        value: parseFloat((totalBuy - totalSell).toFixed(2)),
        change: '+5.1%',
        icon: 'üí∞'
      },
      {
        title: 'Ort. ƒ∞≈ülem B√ºy√ºkl√ºƒü√º',
        value: portfolio.length > 0 
          ? parseFloat(((totalBuy + totalSell) / portfolio.length).toFixed(2))
          : 0,
        change: '+1.8%',
        icon: '‚öñÔ∏è'
      },
      {
        title: 'Aktif Varlƒ±k',
        value: this._countActiveStocks(portfolio),
        change: '0%',
        icon: 'üìà'
      }
    ];
  },
  
  /**
   * UI i√ßin sistem uyarƒ±larƒ±
   */
  _getSystemAlerts: function(portfolio) {
    const alerts = [];
    
    if (portfolio.length === 0) {
      alerts.push({
        type: 'warning',
        message: 'Portf√∂y bo≈ü. Veri ekleyin.',
        priority: 'high'
      });
    }
    
    const freshness = this._calculateDataFreshness(portfolio);
    if (freshness === 'old') {
      alerts.push({
        type: 'error',
        message: 'Veriler eski. G√ºncelleyin.',
        priority: 'high'
      });
    }
    
    const currencyRisk = this._calculateSimpleCurrencyRisk(portfolio);
    if (currencyRisk === 'high') {
      alerts.push({
        type: 'warning',
        message: 'Para birimi √ße≈üitliliƒüi d√º≈ü√ºk.',
        priority: 'medium'
      });
    }
    
    return alerts;
  },
  
  /**
   * UI i√ßin yatƒ±rƒ±m √∂nerileri
   */
  _getInvestmentRecommendations: function(portfolio) {
    return [
      {
        title: '√áe≈üitlendirmeyi Artƒ±rƒ±n',
        description: 'Portf√∂y√ºn√ºzde daha fazla varlƒ±k sƒ±nƒ±fƒ± eklemeyi d√º≈ü√ºn√ºn.',
        priority: 'medium'
      },
      {
        title: 'D√ºzenli Takip',
        description: 'Portf√∂y√ºn√ºz√º haftalƒ±k olarak g√∂zden ge√ßirin.',
        priority: 'low'
      },
      {
        title: 'Risk Y√∂netimi',
        description: 'Stop-loss emirleri kullanmayƒ± d√º≈ü√ºn√ºn.',
        priority: 'high'
      }
    ];
  },
  
  /**
   * Grafik renkleri √ºret
   */
  _generateChartColors: function(count) {
    const colors = [
      '#FF6384', '#36A2EB', '#FFCE56', '#4BC0C0', 
      '#9966FF', '#FF9F40', '#8AC926', '#1982C4',
      '#6A4C93', '#FF595E'
    ];
    
    const result = [];
    for (let i = 0; i < count; i++) {
      result.push(colors[i % colors.length]);
    }
    return result;
  },
  
  /**
   * Fallback UI JSON (hata durumunda)
   */
  _getFallbackUIJSON: function() {
    return {
      error: true,
      message: 'UI verisi hazƒ±rlanamadƒ±',
      fallbackData: {
        charts: {
          assetDistribution: {
            type: 'doughnut',
            data: {
              labels: ['Veri Yok'],
              datasets: [{
                data: [100],
                backgroundColor: ['#CCCCCC']
              }]
            }
          }
        },
        tables: {
          recentTransactions: [],
          topStocks: []
        },
        meta: {
          lastUpdated: new Date().toISOString(),
          dataPoints: 0,
          hasRealTimeData: false
        }
      }
    };
  }
};

// ==================== TEST FONKSƒ∞YONLARI ====================

/**
 * üß™ PORTFOLIO ANALYTICS TESTƒ∞
 */
function test_PortfolioAnalytics_JSON() {
  console.log('üß™ PORTFOLIO ANALYTICS JSON TESTƒ∞ (D√úZELTƒ∞LMƒ∞≈û)');
  console.log('='.repeat(60));
  
  const tests = [
    { 
      name: 'Dashboard JSON', 
      func: () => PortfolioAnalytics.getDashboardJSON(),
      checkSuccess: true
    },
    { 
      name: 'API Response JSON', 
      func: () => PortfolioAnalytics.getAPIResponseJSON('summary'),
      checkSuccess: false // API response farklƒ± yapƒ±da
    },
    { 
      name: 'UI Ready JSON', 
      func: () => PortfolioAnalytics.getUIReadyJSON(),
      checkSuccess: false // UI JSON farklƒ± yapƒ±da
    },
    { 
      name: 'Quick Summary JSON', 
      func: () => PortfolioAnalytics.getQuickSummaryJSON(),
      checkSuccess: false // Quick summary farklƒ± yapƒ±da
    },
    { 
      name: 'Portfolio Report JSON', 
      func: () => PortfolioAnalytics.getPortfolioReportJSON(),
      checkSuccess: true
    }
  ];
  
  let passed = 0;
  let failed = 0;
  
  tests.forEach((test, index) => {
    console.log(`\n${index + 1}. ${test.name} Testi...`);
    
    try {
      const result = test.func();
      
      if (test.checkSuccess) {
        if (result.success !== false && !result.error) {
          console.log(`   ‚úÖ BA≈ûARILI`);
          console.log(`   üìä Veri yapƒ±sƒ±:`, typeof result.data);
          
          // JSON boyutunu kontrol et
          const jsonStr = JSON.stringify(result);
          console.log(`   üì¶ JSON boyutu: ${Math.round(jsonStr.length / 1024 * 100) / 100} KB`);
          passed++;
        } else {
          console.log(`   ‚ùå BA≈ûARISIZ:`, result.error || result.message);
          failed++;
        }
      } else {
        // Farklƒ± yapƒ± kontrol√º
        if (result && !result.error) {
          console.log(`   ‚úÖ BA≈ûARILI`);
          const jsonStr = JSON.stringify(result);
          console.log(`   üì¶ JSON boyutu: ${Math.round(jsonStr.length / 1024 * 100) / 100} KB`);
          passed++;
        } else {
          console.log(`   ‚ùå BA≈ûARISIZ:`, result.error || 'Bilinmeyen hata');
          failed++;
        }
      }
    } catch (error) {
      console.log(`   üí• HATA: ${error.message}`);
      console.log(`   Stack: ${error.stack}`);
      failed++;
    }
  });
  
  console.log('\n' + '='.repeat(60));
  console.log(`üìä TEST SONUCU: ${passed}/${tests.length} ba≈üarƒ±lƒ±`);
  console.log('üß™ TEST TAMAMLANDI');
  
  return { passed, failed, total: tests.length };
}

/**
 * üåê API ENDPOINT TESTƒ∞
 */
function test_PortfolioAnalytics_API_Endpoints() {
  console.log('üåê PORTFOLIO ANALYTICS API ENDPOINT TESTƒ∞');
  console.log('='.repeat(50));
  
  const endpoints = ['summary', 'portfolio', 'analytics', 'health'];
  let successCount = 0;
  
  endpoints.forEach(endpoint => {
    console.log(`\nüì° /api/${endpoint} test ediliyor...`);
    
    const response = PortfolioAnalytics.getAPIResponseJSON(endpoint);
    
    console.log(`   Durum: ${response.status}`);
    console.log(`   Endpoint: ${response.meta?.endpoint}`);
    
    if (response.status === 'success') {
      console.log(`   ‚úÖ BA≈ûARILI`);
      successCount++;
    } else {
      console.log(`   ‚ùå HATA: ${response.error?.message}`);
    }
  });
  
  console.log('\n' + '='.repeat(50));
  console.log(`üìä SONU√á: ${successCount}/${endpoints.length} endpoint ba≈üarƒ±lƒ±`);
  
  return successCount === endpoints.length;
}
/**
 * üîç JSON VERƒ∞ KALƒ∞TESƒ∞ TESTƒ∞ - Detaylƒ± ƒ∞√ßerik Kontrol√º
 * 
 * JSON verilerinin yapƒ±sƒ±nƒ±, i√ßeriƒüini ve doƒüruluƒüunu kontrol eder
 */
function test_JsonData_Quality_Validation() {
  console.log('üîç JSON VERƒ∞ KALƒ∞TESƒ∞ TESTƒ∞ - DETAYLI ƒ∞√áERƒ∞K KONTROL√ú');
  console.log('='.repeat(70));
  
  const testResults = {
    dashboard: { passed: 0, failed: 0, issues: [] },
    api: { passed: 0, failed: 0, issues: [] },
    ui: { passed: 0, failed: 0, issues: [] },
    report: { passed: 0, failed: 0, issues: [] },
    summary: { passed: 0, failed: 0, issues: [] }
  };
  
  // Yardƒ±mcƒ± fonksiyonlar
  const validators = {
    // JSON'un ge√ßerli olup olmadƒ±ƒüƒ±nƒ± kontrol et
    isValidJSON: function(obj) {
      try {
        JSON.stringify(obj);
        return true;
      } catch (e) {
        return false;
      }
    },
    
    // Gerekli alanlarƒ± kontrol et
    hasRequiredFields: function(obj, requiredFields) {
      const missing = [];
      requiredFields.forEach(field => {
        if (!(field in obj)) {
          missing.push(field);
        }
      });
      return missing.length === 0 ? { valid: true } : { 
        valid: false, 
        missing: missing 
      };
    },
    
    // Veri tipini kontrol et
    checkDataType: function(value, expectedType) {
      if (expectedType === 'array') {
        return Array.isArray(value);
      } else if (expectedType === 'date') {
        return value instanceof Date || typeof value === 'string';
      } else if (expectedType === 'number') {
        return typeof value === 'number' && !isNaN(value);
      } else {
        return typeof value === expectedType;
      }
    },
    
    // Pozitif sayƒ± kontrol√º
    isPositiveNumber: function(value) {
      return typeof value === 'number' && value >= 0;
    },
    
    // Tarih formatƒ± kontrol√º
    isValidDateString: function(dateStr) {
      if (!dateStr || typeof dateStr !== 'string') return false;
      return !isNaN(new Date(dateStr).getTime());
    }
  };
  
  // TEST 1: DASHBOARD JSON
  console.log('\n1Ô∏è‚É£ DASHBOARD JSON KALƒ∞TE KONTROL√ú');
  try {
    const dashboardResult = PortfolioAnalytics.getDashboardJSON();
    
    if (dashboardResult.success && dashboardResult.data) {
      const data = dashboardResult.data;
      
      // 1.1. Meta bilgiler kontrol√º
      console.log('   üìã Meta bilgiler kontrol ediliyor...');
      const metaCheck = validators.hasRequiredFields(data.meta, [
        'generatedAt', 'recordCount', 'dataSource', 'version'
      ]);
      
      if (metaCheck.valid) {
        console.log('     ‚úÖ Meta alanlarƒ± mevcut');
        testResults.dashboard.passed++;
      } else {
        console.log(`     ‚ùå Eksik meta alanlarƒ±: ${metaCheck.missing.join(', ')}`);
        testResults.dashboard.failed++;
        testResults.dashboard.issues.push(`Eksik meta alanlarƒ±: ${metaCheck.missing.join(', ')}`);
      }
      
      // 1.2. Summary Cards kontrol√º
      console.log('   üìä Summary Cards kontrol ediliyor...');
      if (data.summaryCards && Array.isArray(data.summaryCards) && data.summaryCards.length === 4) {
        console.log('     ‚úÖ 4 adet summary card mevcut');
        testResults.dashboard.passed++;
        
        // Her card i√ßin temel kontroller
        data.summaryCards.forEach((card, index) => {
          const cardCheck = validators.hasRequiredFields(card, [
            'id', 'title', 'value', 'icon', 'color', 'trend'
          ]);
          
          if (cardCheck.valid && validators.checkDataType(card.value, 'number')) {
            console.log(`     ‚úÖ Card ${index + 1}: "${card.title}" (${card.value})`);
          } else {
            console.log(`     ‚ùå Card ${index + 1} hatalƒ±`);
            testResults.dashboard.issues.push(`Card ${index + 1} hatalƒ±: ${card.title}`);
          }
        });
      } else {
        console.log('     ‚ùå Summary Cards eksik veya hatalƒ±');
        testResults.dashboard.failed++;
      }
      
      // 1.3. Recent Transactions kontrol√º
      console.log('   üìÖ Recent Transactions kontrol ediliyor...');
      if (data.recentTransactions && Array.isArray(data.recentTransactions)) {
        console.log(`     ‚úÖ ${data.recentTransactions.length} recent transaction`);
        testResults.dashboard.passed++;
        
        // ƒ∞lk transaction'ƒ± kontrol et
        if (data.recentTransactions.length > 0) {
          const firstTx = data.recentTransactions[0];
          const txCheck = validators.hasRequiredFields(firstTx, [
            'id', 'date', 'asset', 'type', 'amount', 'price', 'total'
          ]);
          
          if (txCheck.valid) {
            console.log(`     ‚úÖ ƒ∞lk transaction: ${firstTx.asset} (${firstTx.type})`);
          }
        }
      }
      
      // 1.4. Currency Distribution kontrol√º
      console.log('   üí± Currency Distribution kontrol ediliyor...');
      if (data.currencyDistribution && typeof data.currencyDistribution === 'object') {
        const currencyCount = Object.keys(data.currencyDistribution).length;
        console.log(`     ‚úÖ ${currencyCount} para birimi`);
        testResults.dashboard.passed++;
      }
      
      // 1.5. Timeline kontrol√º
      console.log('   üìà Timeline kontrol ediliyor...');
      if (data.timeline && typeof data.timeline === 'object') {
        const timelineDays = Object.keys(data.timeline).length;
        console.log(`     ‚úÖ ${timelineDays} g√ºnl√ºk timeline`);
        testResults.dashboard.passed++;
      }
      
      // 1.6. JSON validasyonu
      console.log('   üì¶ JSON validasyonu...');
      if (validators.isValidJSON(data)) {
        console.log('     ‚úÖ Ge√ßerli JSON formatƒ±');
        testResults.dashboard.passed++;
      } else {
        console.log('     ‚ùå Ge√ßersiz JSON');
        testResults.dashboard.failed++;
      }
      
    } else {
      console.log('   ‚ùå Dashboard verisi alƒ±namadƒ±');
      testResults.dashboard.failed++;
    }
    
  } catch (error) {
    console.log(`   üí• Dashboard test hatasƒ±: ${error.message}`);
    testResults.dashboard.failed++;
  }
  
  // TEST 2: API RESPONSE JSON
  console.log('\n2Ô∏è‚É£ API RESPONSE JSON KALƒ∞TE KONTROL√ú');
  try {
    const apiResult = PortfolioAnalytics.getAPIResponseJSON('summary');
    
    if (apiResult.status === 'success' && apiResult.data) {
      const data = apiResult.data;
      
      console.log('   üì° API Response yapƒ±sƒ± kontrol ediliyor...');
      
      // Gerekli alanlar
      const requiredFields = ['totalRecords', 'totalInvestment', 'activeStocks', 'dateRange', 'lastUpdated'];
      const fieldCheck = validators.hasRequiredFields(data, requiredFields);
      
      if (fieldCheck.valid) {
        console.log('     ‚úÖ T√ºm gerekli alanlar mevcut');
        testResults.api.passed++;
        
        // Deƒüer kontrolleri
        if (validators.checkDataType(data.totalRecords, 'number') && data.totalRecords >= 0) {
          console.log(`     ‚úÖ totalRecords: ${data.totalRecords}`);
          testResults.api.passed++;
        } else {
          console.log(`     ‚ùå totalRecords hatalƒ±: ${data.totalRecords}`);
          testResults.api.failed++;
        }
        
        if (validators.checkDataType(data.totalInvestment, 'number')) {
          console.log(`     ‚úÖ totalInvestment: ${data.totalInvestment}`);
          testResults.api.passed++;
        }
        
        if (validators.checkDataType(data.activeStocks, 'number') && data.activeStocks >= 0) {
          console.log(`     ‚úÖ activeStocks: ${data.activeStocks}`);
          testResults.api.passed++;
        }
        
        if (data.dateRange && typeof data.dateRange === 'object') {
          console.log(`     ‚úÖ dateRange: ${data.dateRange.start} - ${data.dateRange.end}`);
          testResults.api.passed++;
        }
        
        if (validators.isValidDateString(data.lastUpdated)) {
          console.log(`     ‚úÖ lastUpdated: ${data.lastUpdated}`);
          testResults.api.passed++;
        }
        
      } else {
        console.log(`     ‚ùå Eksik alanlar: ${fieldCheck.missing.join(', ')}`);
        testResults.api.failed++;
        testResults.api.issues.push(`Eksik alanlar: ${fieldCheck.missing.join(', ')}`);
      }
      
    } else {
      console.log(`   ‚ùå API Response ba≈üarƒ±sƒ±z: ${apiResult.error?.message}`);
      testResults.api.failed++;
    }
    
  } catch (error) {
    console.log(`   üí• API test hatasƒ±: ${error.message}`);
    testResults.api.failed++;
  }
  
  // TEST 3: UI READY JSON
  console.log('\n3Ô∏è‚É£ UI READY JSON KALƒ∞TE KONTROL√ú');
  try {
    const uiResult = PortfolioAnalytics.getUIReadyJSON();
    
    // Hata durumu kontrol√º
    if (uiResult.error) {
      console.log('   ‚ö†Ô∏è UI JSON hata durumunda: ' + uiResult.message);
      // Fallback data'yƒ± kontrol et
      if (uiResult.fallbackData) {
        console.log('   ‚ÑπÔ∏è Fallback data mevcut');
        testResults.ui.passed++;
      }
    } else {
      console.log('   üé® UI JSON yapƒ±sƒ± kontrol ediliyor...');
      
      // 3.1. Charts kontrol√º
      if (uiResult.charts && typeof uiResult.charts === 'object') {
        const chartTypes = Object.keys(uiResult.charts);
        console.log(`     ‚úÖ ${chartTypes.length} chart tipi: ${chartTypes.join(', ')}`);
        testResults.ui.passed++;
        
        // Her chart i√ßin temel kontrol
        chartTypes.forEach(chartType => {
          const chart = uiResult.charts[chartType];
          if (chart.data && chart.options) {
            console.log(`     ‚úÖ "${chartType}" chart yapƒ±sƒ± doƒüru`);
            testResults.ui.passed++;
          }
        });
      }
      
      // 3.2. Tables kontrol√º
      if (uiResult.tables && typeof uiResult.tables === 'object') {
        const tableTypes = Object.keys(uiResult.tables);
        console.log(`     ‚úÖ ${tableTypes.length} tablo: ${tableTypes.join(', ')}`);
        testResults.ui.passed++;
      }
      
      // 3.3. Components kontrol√º
      if (uiResult.components && typeof uiResult.components === 'object') {
        const componentTypes = Object.keys(uiResult.components);
        console.log(`     ‚úÖ ${componentTypes.length} bile≈üen: ${componentTypes.join(', ')}`);
        testResults.ui.passed++;
      }
      
      // 3.4. Meta bilgiler
      if (uiResult.meta && typeof uiResult.meta === 'object') {
        const metaCheck = validators.hasRequiredFields(uiResult.meta, [
          'lastUpdated', 'dataPoints', 'hasRealTimeData', 'refreshInterval'
        ]);
        
        if (metaCheck.valid) {
          console.log('     ‚úÖ Meta bilgileri mevcut');
          testResults.ui.passed++;
        }
      }
      
      // 3.5. JSON validasyonu
      if (validators.isValidJSON(uiResult)) {
        console.log('     ‚úÖ Ge√ßerli JSON formatƒ±');
        testResults.ui.passed++;
      }
    }
    
  } catch (error) {
    console.log(`   üí• UI test hatasƒ±: ${error.message}`);
    testResults.ui.failed++;
  }
  
  // TEST 4: PORTFOLIO REPORT JSON
  console.log('\n4Ô∏è‚É£ PORTFOLIO REPORT JSON KALƒ∞TE KONTROL√ú');
  try {
    const reportResult = PortfolioAnalytics.getPortfolioReportJSON();
    
    if (reportResult.success && reportResult.data) {
      const report = reportResult.data;
      
      console.log('   üìÑ Rapor yapƒ±sƒ± kontrol ediliyor...');
      
      // 4.1. Executive Summary kontrol√º
      if (report.executiveSummary && typeof report.executiveSummary === 'object') {
        const summaryCheck = validators.hasRequiredFields(report.executiveSummary, [
          'totalRecords', 'dateRange', 'totalInvestment', 'totalReturn', 'roi'
        ]);
        
        if (summaryCheck.valid) {
          console.log('     ‚úÖ Executive Summary mevcut');
          testResults.report.passed++;
          
          // ROI kontrol√º (y√ºzde olmalƒ±)
          if (typeof report.executiveSummary.roi === 'number') {
            console.log(`     ‚úÖ ROI: %${report.executiveSummary.roi}`);
            testResults.report.passed++;
          }
        }
      }
      
      // 4.2. FIFO Analysis kontrol√º
      if (report.fifoAnalysis && typeof report.fifoAnalysis === 'object') {
        const fifoCheck = validators.hasRequiredFields(report.fifoAnalysis, [
          'profitLossByStock', 'totalProfit', 'profitDistribution'
        ]);
        
        if (fifoCheck.valid) {
          console.log(`     ‚úÖ FIFO Analysis mevcut (${Object.keys(report.fifoAnalysis.profitLossByStock || {}).length} hisse)`);
          testResults.report.passed++;
        }
      }
      
      // 4.3. Stock Details kontrol√º
      if (report.stockDetails && typeof report.stockDetails === 'object') {
        const stockCount = Object.keys(report.stockDetails).length;
        console.log(`     ‚úÖ ${stockCount} hisse detayƒ±`);
        testResults.report.passed++;
      }
      
      // 4.4. Transaction History kontrol√º
      if (report.transactionHistory && Array.isArray(report.transactionHistory)) {
        console.log(`     ‚úÖ ${report.transactionHistory.length} i≈ülem ge√ßmi≈üi`);
        testResults.report.passed++;
        
        // ƒ∞lk i≈ülemi kontrol et
        if (report.transactionHistory.length > 0) {
          const firstTx = report.transactionHistory[0];
          const txFields = Object.keys(firstTx);
          console.log(`     ‚úÖ ƒ∞lk i≈ülemde ${txFields.length} alan: ${txFields.slice(0, 3).join(', ')}...`);
          testResults.report.passed++;
        }
      }
      
      // 4.5. Rapor boyutu kontrol√º
      const reportSize = JSON.stringify(report).length;
      console.log(`     üì¶ Rapor boyutu: ${Math.round(reportSize / 1024 * 100) / 100} KB`);
      
      if (reportSize > 100) { // Minimum 100 byte
        console.log('     ‚úÖ Rapor boyutu yeterli');
        testResults.report.passed++;
      } else {
        console.log('     ‚ö†Ô∏è Rapor boyutu √ßok k√º√ß√ºk');
        testResults.report.issues.push('Rapor boyutu √ßok k√º√ß√ºk');
      }
      
    } else {
      console.log(`   ‚ùå Rapor alƒ±namadƒ±: ${reportResult.message}`);
      testResults.report.failed++;
    }
    
  } catch (error) {
    console.log(`   üí• Rapor test hatasƒ±: ${error.message}`);
    testResults.report.failed++;
  }
  
  // TEST 5: QUICK SUMMARY JSON
  console.log('\n5Ô∏è‚É£ QUICK SUMMARY JSON KALƒ∞TE KONTROL√ú');
  try {
    const summaryResult = PortfolioAnalytics.getQuickSummaryJSON();
    
    console.log('   ‚ö° Quick Summary kontrol ediliyor...');
    
    // 5.1. Temel yapƒ±
    const requiredFields = ['timestamp', 'summary', 'performance'];
    const fieldCheck = validators.hasRequiredFields(summaryResult, requiredFields);
    
    if (fieldCheck.valid) {
      console.log('     ‚úÖ Temel yapƒ± doƒüru');
      testResults.summary.passed++;
    } else {
      console.log(`     ‚ùå Eksik alanlar: ${fieldCheck.missing.join(', ')}`);
      testResults.summary.failed++;
    }
    
    // 5.2. Summary b√∂l√ºm√º
    if (summaryResult.summary && typeof summaryResult.summary === 'object') {
      const summaryFields = Object.keys(summaryResult.summary);
      console.log(`     ‚úÖ Summary'de ${summaryFields.length} alan`);
      testResults.summary.passed++;
      
      // ƒ∞≈ülem sayƒ±larƒ± kontrol√º
      if (summaryResult.summary.totalTransactions >= 0) {
        console.log(`     ‚úÖ Toplam i≈ülem: ${summaryResult.summary.totalTransactions}`);
        testResults.summary.passed++;
      }
      
      if (summaryResult.summary.netInvestment !== undefined) {
        console.log(`     ‚úÖ Net yatƒ±rƒ±m: ${summaryResult.summary.netInvestment}`);
        testResults.summary.passed++;
      }
    }
    
    // 5.3. Performans b√∂l√ºm√º
    if (summaryResult.performance && typeof summaryResult.performance === 'object') {
      console.log('     ‚úÖ Performance b√∂l√ºm√º mevcut');
      testResults.summary.passed++;
    }
    
    // 5.4. Hƒ±zlƒ± olma kontrol√º (timestamp ile)
    if (summaryResult.timestamp && validators.isValidDateString(summaryResult.timestamp)) {
      const reportTime = new Date(summaryResult.timestamp);
      const now = new Date();
      const diffSeconds = (now - reportTime) / 1000;
      
      if (diffSeconds < 10) { // 10 saniyeden daha taze
        console.log(`     ‚úÖ Veri taze (${diffSeconds.toFixed(1)} saniye √∂nce)`);
        testResults.summary.passed++;
      } else {
        console.log(`     ‚ö†Ô∏è Veri biraz eski (${diffSeconds.toFixed(0)} saniye)`);
      }
    }
    
  } catch (error) {
    console.log(`   üí• Summary test hatasƒ±: ${error.message}`);
    testResults.summary.failed++;
  }
  
  // GENEL DEƒûERLENDƒ∞RME
  console.log('\n' + '='.repeat(70));
  console.log('üìä JSON VERƒ∞ KALƒ∞TESƒ∞ TEST SONU√áLARI');
  console.log('='.repeat(70));
  
  const allTests = [
    { name: 'Dashboard', result: testResults.dashboard },
    { name: 'API Response', result: testResults.api },
    { name: 'UI Ready', result: testResults.ui },
    { name: 'Portfolio Report', result: testResults.report },
    { name: 'Quick Summary', result: testResults.summary }
  ];
  
  let totalPassed = 0;
  let totalFailed = 0;
  let totalTests = 0;
  
  allTests.forEach(test => {
    const passed = test.result.passed;
    const failed = test.result.failed;
    const total = passed + failed;
    
    totalPassed += passed;
    totalFailed += failed;
    totalTests += total;
    
    const percentage = total > 0 ? Math.round((passed / total) * 100) : 0;
    
    console.log(`üìã ${test.name}:`);
    console.log(`   ‚úÖ Ge√ßen: ${passed}`);
    console.log(`   ‚ùå Kalan: ${failed}`);
    console.log(`   üìà Ba≈üarƒ±: %${percentage}`);
    
    if (test.result.issues.length > 0) {
      console.log(`   ‚ö†Ô∏è  Sorunlar:`);
      test.result.issues.forEach((issue, idx) => {
        console.log(`      ${idx + 1}. ${issue}`);
      });
    }
  });
  
  const overallPercentage = totalTests > 0 ? Math.round((totalPassed / totalTests) * 100) : 0;
  
  console.log('\n' + '='.repeat(70));
  console.log('üéØ GENEL SONU√á');
  console.log('='.repeat(70));
  console.log(`Toplam Test: ${totalTests}`);
  console.log(`Ba≈üarƒ±lƒ±: ${totalPassed}`);
  console.log(`Ba≈üarƒ±sƒ±z: ${totalFailed}`);
  console.log(`Genel Ba≈üarƒ± Oranƒ±: %${overallPercentage}`);
  
  // Kalite seviyesi deƒüerlendirmesi
  let qualityLevel = '';
  let emoji = '';
  
  if (overallPercentage >= 90) {
    qualityLevel = 'M√úKEMMEL';
    emoji = 'üèÜ';
  } else if (overallPercentage >= 75) {
    qualityLevel = 'ƒ∞Yƒ∞';
    emoji = '‚úÖ';
  } else if (overallPercentage >= 60) {
    qualityLevel = 'ORTA';
    emoji = '‚ö†Ô∏è';
  } else {
    qualityLevel = 'D√ú≈û√úK';
    emoji = '‚ùå';
  }
  
  console.log(`Kalite Seviyesi: ${qualityLevel} ${emoji}`);
  
  // √ñneriler
  console.log('\nüí° √ñNERƒ∞LER:');
  
  if (testResults.dashboard.failed > 0) {
    console.log('1. Dashboard JSON: Eksik alanlarƒ± tamamlayƒ±n');
  }
  
  if (testResults.api.failed > 0) {
    console.log('2. API Response: Veri tiplerini kontrol edin');
  }
  
  if (testResults.ui.issues.length > 0) {
    console.log('3. UI JSON: Chart veri yapƒ±larƒ±nƒ± g√∂zden ge√ßirin');
  }
  
  if (testResults.report.issues.includes('Rapor boyutu √ßok k√º√ß√ºk')) {
    console.log('4. Rapor: Daha detaylƒ± veri ekleyin');
  }
  
  if (overallPercentage >= 90) {
    console.log('üéâ TEBRƒ∞KLER! JSON verileriniz y√ºksek kalitede.');
    console.log('   Artƒ±k bu verileri g√ºvenle kullanabilirsiniz.');
  }
  
  return {
    overallScore: overallPercentage,
    qualityLevel: qualityLevel,
    details: testResults,
    timestamp: new Date().toISOString()
  };
}

/**
 * üìä JSON √ñRNEK G√ñSTERƒ∞M TESTƒ∞
 * Her JSON formatƒ±ndan √∂rnek bir kƒ±smƒ± g√∂sterir
 */
function show_Json_Samples() {
  console.log('üìä JSON VERƒ∞ √ñRNEKLERƒ∞');
  console.log('='.repeat(60));
  
  try {
    // 1. Dashboard √∂rneƒüi
    console.log('\n1Ô∏è‚É£ DASHBOARD JSON √ñRNEƒûƒ∞:');
    const dashboard = PortfolioAnalytics.getDashboardJSON();
    if (dashboard.success) {
      const sample = {
        meta: dashboard.data.meta,
        summaryCards: dashboard.data.summaryCards.map(card => ({
          title: card.title,
          value: card.value,
          currency: card.currency || 'TRY'
        })),
        recentTransactionsCount: dashboard.data.recentTransactions?.length || 0
      };
      console.log(JSON.stringify(sample, null, 2));
    }
    
    // 2. API Response √∂rneƒüi
    console.log('\n2Ô∏è‚É£ API RESPONSE √ñRNEƒûƒ∞ (summary):');
    const api = PortfolioAnalytics.getAPIResponseJSON('summary');
    console.log(JSON.stringify(api, null, 2));
    
    // 3. UI JSON √∂rneƒüi (sadece charts b√∂l√ºm√º)
    console.log('\n3Ô∏è‚É£ UI JSON √ñRNEƒûƒ∞ (charts b√∂l√ºm√º):');
    const ui = PortfolioAnalytics.getUIReadyJSON();
    if (!ui.error) {
      const chartSample = {};
      Object.keys(ui.charts).forEach(chartName => {
        chartSample[chartName] = {
          type: ui.charts[chartName].type,
          dataPoints: ui.charts[chartName].data?.labels?.length || 0
        };
      });
      console.log(JSON.stringify(chartSample, null, 2));
    }
    
    // 4. Rapor √∂rneƒüi (executive summary)
    console.log('\n4Ô∏è‚É£ RAPOR √ñRNEƒûƒ∞ (executive summary):');
    const report = PortfolioAnalytics.getPortfolioReportJSON();
    if (report.success) {
      console.log(JSON.stringify(report.data.executiveSummary, null, 2));
    }
    
    // 5. Quick Summary √∂rneƒüi
    console.log('\n5Ô∏è‚É£ QUICK SUMMARY √ñRNEƒûƒ∞:');
    const summary = PortfolioAnalytics.getQuickSummaryJSON();
    console.log(JSON.stringify(summary, null, 2));
    
  } catch (error) {
    console.error('‚ùå √ñrnek g√∂sterim hatasƒ±:', error.message);
  }
}

/**
 * üß™ T√úM JSON TESTLERƒ∞Nƒ∞ √áALI≈ûTIR
 */
function run_All_Json_Tests() {
  console.log('üöÄ T√úM JSON TESTLERƒ∞ BA≈ûLATILIYOR');
  console.log('='.repeat(70));
  
  const startTime = new Date();
  
  // 1. Temel fonksiyon testi
  console.log('\nüìã 1. TEMEL FONKSƒ∞YON TESTƒ∞');
  const basicTest = test_PortfolioAnalytics_JSON();
  console.log(`   Sonu√ß: ${basicTest.passed}/${basicTest.total} ba≈üarƒ±lƒ±`);
  
  // 2. API endpoint testi
  console.log('\nüìã 2. API ENDPOINT TESTƒ∞');
  const apiTest = test_PortfolioAnalytics_API_Endpoints();
  console.log(`   Sonu√ß: ${apiTest ? '‚úÖ BA≈ûARILI' : '‚ùå BA≈ûARISIZ'}`);
  
  // 3. Kalite testi
  console.log('\nüìã 3. KALƒ∞TE KONTROL TESTƒ∞');
  const qualityTest = test_JsonData_Quality_Validation();
  
  // 4. √ñrnek g√∂sterim
  console.log('\nüìã 4. √ñRNEK G√ñSTERƒ∞M');
  show_Json_Samples();
  
  const duration = (new Date() - startTime) / 1000;
  
  console.log('\n' + '='.repeat(70));
  console.log('üéâ T√úM TESTLER TAMAMLANDI');
  console.log(`‚è±Ô∏è  Toplam s√ºre: ${duration.toFixed(2)} saniye`);
  console.log('='.repeat(70));
  
  return {
    basicTest: basicTest,
    apiTest: apiTest,
    qualityTest: qualityTest,
    duration: duration
  };
}